<img src="./img/roadmap/js/promises/head.webp" alt="" class="head" />

<h5>Promise Syntax</h5>

<p>ES6 introduced Promises. In many tutorials, you'll read something like:</p>

<blockquote>"A promise is a placeholder for a value that can either resolve or reject at some time in the future"</blockquote>

<p>We can create a promise, using a <code>Promise</code> constructor that receives a callback. Okay cool, let's try it out!</p>


<img src="./img/roadmap/js/promises/1.gif" />

<p>A <code>Promise</code> is an object that contains a <strong>status</strong>, (<code>[[PromiseStatus]]</code>) and a <strong>value</strong> (<code>[[PromiseValue]]</code>). In the above example, you can see that the value of <code>[[PromiseStatus]]</code> is <code>"pending"</code>, and the value of the promise is <code>undefined</code>.</p>

<p>You'll never have to interact with this object, you can't even access the <code>[[PromiseStatus]]</code> and <code>[[PromiseValue]]</code> properties! However, the values of these properties are important when working with promises.</p>

<p>The value of the <code>PromiseStatus</code>, the <strong>state</strong>, can be one of three values:</p>

<ol>
	<li>‚úÖ <code>fulfilled</code>: The promise has been <code>resolved</code>. Everything went fine, no errors occurred within the promise ü•≥</li>
	<li>‚ùå <code>rejected</code> : The promise has been <code>rejected</code>. Argh, something went wrong..</li>
	<li>‚è≥ <code>pending</code>: The promise has neither resolved nor rejected (yet), the promise is still <code>pending</code>. </li>
</ol>

<p>Alright this all sounds great, but <em>when</em> is a promise status <code>"pending"</code>, <code>"fulfilled"</code> or <code>"rejected"</code>? And why does that status even matter?</p>

<p>In the above example, we just passed the simple callback function <code>() =&gt; {}</code> to the <code>Promise</code> constructor. However, this callback function actually receives two arguments. The value of the first argument, often called <code>resolve</code> or <code>res</code>, is the method to be called when the Promise should <strong>resolve</strong>. The value of the second argument, often called <code>reject</code> or <code>rej</code>, is the value method to be called when the Promise should <strong>reject</strong>, something went wrong.</p>

<img src="./img/roadmap/js/promises/1.png" />

<p>Let's try and see that gets logged when we invoke either the <code>resolve</code> or <code>reject</code> method! In my example, I called the <code>resolve</code> method <code>res</code>, and the <code>reject</code> method <code>rej</code>.</p>

<img src="./img/roadmap/js/promises/2.gif" />

<p>Awesome! We finally know how to get rid of the <code>"pending"</code> status and the <code>undefined</code> value! The <strong>status</strong> of a promise is <code>"fulfilled"</code> if we invoked the <code>resolve</code> method, and the status of the promise is <code>"rejected</code>" if we invoked the <code>rejected</code> method.</p>

<p>The <strong>value</strong> of a promise, the value of <code>[[PromiseValue]]</code>, is the value that we pass to the either the <code>resolved</code> or <code>rejected</code> method as their argument.</p>

<p>Okay so, now we know a little bit better how to control that vague <code>Promise</code> object. But what is it used for?</p>

<p>Luckily, Promises can help us fix this! First, let's rewrite the entire code block, so that each function returns a <code>Promise</code> instead.</p>

<p>If the image is loaded and everything went fine, let's <strong>resolve</strong> the promise with the loaded image! Else, if there was an error somewhere while loading the file, let's <strong>reject</strong> the promise with the error that occurred.</p>

<img src="./img/roadmap/js/promises/2.png" />

<p>Let's see what happens when we run this in the terminal!</p>

<img src="./img/roadmap/js/promises/3.gif" />

<p>Cool! A promise got returned with the value of the parsed data, just like we expected.</p>

<p>But... what now? We don't care about that entire promise object, we only care about the value of the data! Luckily, there are built-in methods to get a promise's value. To a promise, we can attach 3 methods:</p>

<ol>
	<li>
		<code>.then()</code>: Gets called after a promise <em>resolved</em>.
	</li>
	<li>
		<code>.catch()</code>: Gets called after a promise <em>rejected</em>.
	</li>
	<li>
		<code>.finally()</code>: <em>Always</em> gets called, whether the promise resolved or rejected.
	</li>
</ol>

<img src="./img/roadmap/js/promises/3.png" />

<p>The <code>.then</code> method receives the value passed to the <code>resolve</code> method.</p>

<img src="./img/roadmap/js/promises/4.gif" />

<p>The <code>.catch</code> method receives the value passed to the <code>rejected</code> method</p>

<img src="./img/roadmap/js/promises/5.gif" />

<p>Finally, we have the value that got resolved by the promise without having that entire promise object! We can now do whatever we want with this value.</p>

<p>FYI, when you know that a promise will always resolve or always reject, you can write <code>Promise.resolve</code> or <code>Promise.reject</code> , with the value you want to reject or resolve the promise with!</p>

<img src="./img/roadmap/js/promises/4.png" />

<p>In the <code>getImage</code> example,  we ended up having to nest multiple callbacks in order to run them. Luckily, the <code>.then</code> handlers can help us with that! ü•≥</p>

<p>The result of the <code>.then</code> itself is a promise value. This means that we can chain as many <code>.then</code>s as we want: the result of the previous <code>then</code> callback will be passed as an argument to the next <code>then</code> callback! </p>

<img src="./img/roadmap/js/promises/5.png" />

<p>In the case of the <code>getImage</code> example, we can chain multiple <code>then</code> callbacks in order to pass the processed image onto the next function! Instead of ending up with many nested callbacks, we get a clean <code>then</code> chain. </p>

<img src="./img/roadmap/js/promises/6.png" />

<p>Perfect! This syntax already looks way better than the nested callbacks.</p>


<h5>Microtasks and (Macro)tasks</h5>

<p>Okay so we know a little better how to create a promise and how to extract values out of a promise. Let's add some more code to the script, and run it again:</p>

<img src="./img/roadmap/js/promises/6.gif" />

<p>Wait what?! ü§Ø</p>

<p>First, <code>Start!</code> got logged. Okay we could've seen that one coming: <code>console.log('Start!')</code> is on the very first line! However, the second value that got logged was <code>End!</code>, and <em>not</em> the value of the resolved promise! Only after <code>End!</code> was logged, the value of the promise got logged. What's going on here?</p>

<p>We've finally seen the true power of promises! üöÄ Although JavaScript is single-threaded, we can add asynchronous behavior using a <code>Promise</code>!</p>

<hr>

<p>But wait, haven't we seen that before? ü§î In the <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">JavaScript event loop</a>, can't we also use methods native to the browser such as <code>setTimeout</code> to create some sort of asynchronous behavior? </p>
<p>Yes! However, within the Event Loop, there are actually two types of queues: the <strong>(macro)task queue</strong> (or just called the <strong>task queue</strong>), and the <strong>microtask queue</strong>. The (macro)task queue is for <strong>(macro)tasks</strong> and the microtask queue is for <strong>microtasks</strong>.</p>
<p>So what's a <em>(macro)task</em> and what's a <em>microtask</em>? Although there are a few more than I'll cover here, the most common are shown in the table below!</p>

<p>
	<table>
		<tbody>
			<tr>
				<td>
					(Macro)task
				</td>
				<td>
					<code>setTimeout</code> | <code>setInterval</code> | <code>setImmediate</code>
				</td>
			</tr>
			<tr>
				<td>
					Microtask
				</td>
				<td>
					<code>process.nextTick</code> | <code>Promise callback</code> | <code>queueMicrotask</code>
				</td>
			</tr>
		</tbody>
	</table>
</p>

<p>Ahh, we see <code>Promise</code> in the microtask list! üòÉ When a <code>Promise</code> resolves and calls its <code>then()</code>, <code>catch()</code> or <code>finally()</code>, method, the callback within the method gets added to the <strong>microtask queue</strong>! This means that the callback within the <code>then()</code>, <code>catch()</code> or <code>finally()</code> method isn't executed immediately, essentially adding some async behavior to our JavaScript code! </p>

<p>So when <em>is</em> a <code>then()</code>, <code>catch()</code> or <code>finally()</code> callback executed? The event loop gives a different priority to the tasks:</p>

<ol>
	<li>All functions in that are currently in the <strong>call stack</strong> get executed. When they returned a value, they get popped off the stack.</li>
	<li>When the call stack is empty, <em>all</em> queued up <strong>microtasks</strong> are popped onto the callstack one by one, and get executed! (Microtasks themselves can also return new microtasks, effectively creating an infinite microtask loop üò¨)</li>
	<li>If both the call stack and microtask queue are empty, the event loop checks if there are tasks left on the (macro)task queue. The tasks get popped onto the callstack, executed, and popped off! </li>
</ol>


<h3>Example</h3>

<h5>Let's take a look at a quick example, simply using:</h5>

<ul>
	<li>
		<code>Task1</code>: a function that's added to the call stack immediately, for example by invoking it instantly in our code.
	</li>
	<li>
		<code>Task2</code>, <code>Task3</code>, <code>Task4</code>:  microtasks, for example a promise <code>then</code> callback, or a task added with <code>queueMicrotask</code>.
	</li>
	<li>
		<code>Task5</code>, <code>Task6</code>: a (macro)task, for example a <code>setTimeout</code> or <code>setImmediate</code> callback
	</li>
</ul>

<img src="./img/roadmap/js/promises/7.gif" />

<p>First, <code>Task1</code> returned a value and got popped off the call stack. Then, the engine checked for tasks queued in the microtask queue. Once all the tasks were put on the call stack and eventually popped off, the engine checked for tasks on the (macro)task queue, which got popped onto the call stack, and popped off when they returned a value.</p>

<h5>Let's use it with some real code!</h5>

<img src="./img/roadmap/js/promises/7.png" />

<p>In this code, we have the macro task <code>setTimeout</code>, and the microtask promise <code>then()</code> callback. Once the engine reaches the line of the <code>setTimeout</code> function. Let's run this code step-by-step, and see what gets logged!</p>


<p>On the first line, the engine encounters the <code>console.log()</code> method. It gets added to the call stack, after which it logs the value <code>Start!</code> to the console. The method gets popped off the call stack, and the engine continues.</p>

<img src="./img/roadmap/js/promises/8.gif" />

<p>The engine encounters the <code>setTimeout</code> method, which gets popped on to the call stack. The <code>setTimeout</code> method is native to the browser: its callback function (<code>() =&gt; console.log('In timeout')</code>) will get added to the Web API, until the timer is done. Although we provided the value <code>0</code> for the timer, the call back still gets pushed to the Web API first, after which it gets added to the <strong>(macro)task queue</strong>: <code>setTimeout</code> is a macro task!</p>

<img src="./img/roadmap/js/promises/9.gif" />

<p>The engine encounters the <code>Promise.resolve()</code> method. The <code>Promise.resolve()</code> method gets added to the call stack, after which is resolves with the value <code>Promise!</code>. Its callback function, the <code>then()</code> method in this case, gets added to the <strong>microtask queue</strong>.</p>

<img src="./img/roadmap/js/promises/10.gif" />

<p>The engine encounters the <code>console.log()</code> method. It gets added to the call stack immediately, after which it logs the value <code>End!</code> to the console, gets popped off the call stack, and the engine continues.</p>

<img src="./img/roadmap/js/promises/11.gif" />

<p>The engine sees the callstack is empty now. Since the call stack is empty, it's going to check whether there are queued tasks in the <strong>microtask queue</strong>! And yes there are, the promise <code>then</code> callback is waiting for its turn! It gets popped onto the call stack, after which it logs the resolved value of the promise: the string <code>Promise!</code>in this case.</p>

<img src="./img/roadmap/js/promises/12.gif" />

<p>The engine sees the call stack is empty, so it's going to check the microtask queue once again to see if tasks are queued. Nope, the microqueue is all empty.</p>

<p>It's time to check the <strong>(macro)task queue</strong>: the <code>setTimeout</code> callback is still waiting there! The <code>setTimeout</code> callback gets popped on to the callstack. The callback function returns the <code>console.log</code> method, which logs the string <code>"In timeout!"</code>. The <code>setTimeout</code> callback get popped off the callstack.</p>

<img src="./img/roadmap/js/promises/13.gif" />

<p>Finally, all done! ü•≥ It seems like the output we saw earlier wasn't so unexpected after all.</p>


<h4>Data Types</h4>

<pre class="language-javascript">
	<code>
		"Any text" // 1. String
		123.45 // 2. Number
		true or false // 3. Boolean
		null // 4. Null
		undefined // 5. Undefined
		Symbol('something') // 6. Symbol
		{ key: 'value'} // 7. Object
		[1, "text", false] // - Array
		function name() { } // - Function
	</code>
</pre>


<h4>Object</h4>

<p>An object is a data type in JavaScript that is used to store a combination of data in a simple key-value pair.</p>

<pre class="language-javascript">
	<code>
		var hero = {
		name: "Thor",
		yearOfBirth: '-15621651',
		calculateAge: function(){
		// some code to calculate age
	}
}

</code>
</pre>


<h4>Function</h4>
<p>Функция — это мини-программа, которая получает на вход какие-то данные, что-то делает внутри себя и может отдавать какие-то данные в результате вычислений.</p>



<h3>OOP</h3>

<h4>Объект</h4>
<p>Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм</p>

<ul>
	<li>
		<p><span>инкапсуляция</span> — объект независим</p>
		<p>Нужные для объекта данные живут внутри этого объекта, а не где-то снаружи в программе (например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку»).
		Также означает скрытие внутренней реализации от других компонентов. Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения (<a target="blank" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title='Метод чтения, геттер (getter — получатель) — специальный метод, позволяющий получить данные, доступ к которым напрямую ограничен.'>геттер</a>) и изменения (<a target="blank" href="" title='Устанавливающий метод, сеттер (англ. setter) или модифицирующий метод, мутатор (англ. mutator) — метод, используемый в объектно-ориентированном программировании для того, чтобы присвоить какое-либо значение инкапсулированному полю, например, обработав при этом недопустимые присваивания.'>сеттер</a>) её значения.</p>
	</li>
	<li>
		<p><span>абстракция</span> — у объекта есть «<a target="blank" href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)' title="Интерфе́йс (англ. interface) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).">интерфейс</a>»</p>
		<p>Aбстракция нужна что бы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи</p>
		<p>у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс.

		В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения.

		Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.</p>
		<img src="https://thecode.media/wp-content/uploads/2019/09/7-1.jpg" alt="" />
	</li>
	<li>
		<p><span>наследование</span> — единый язык общения</p>
		<p>ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать.

			Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить».

			На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у идеального покупателя, плюс могут быть какие-то свои, если захотите.

		Идеальные объекты программисты называют классами.</p>
	</li>
	<li>
		<p><span>полиморфизм</span> — способность к копированию</p>
		<p>В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть».

		При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.</p>
		<img src="https://thecode.media/wp-content/uploads/2019/09/8-1.jpg" alt="" />
		<p>Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если правила работы с ним остались прежними.</p>
	</li>
</ul>

<p>Плюсы и минусы ООП
	У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов.

	Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объект и из чего он состоит.
	Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием.
	Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок.
	Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип.
	А теперь про минусы:
	Сложно понять и начать работать. Подход ООП намного сложнее обычного процедурного программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода.
	Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная.
Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем процедурная (хотя с современными мощностями процессоров это мало кого волнует).</p>

<p>Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании</p>
<p>данные внутри объекта называются свойствами, а функции — методами</p>

<h3>
	How web browser works step by step in 2019 — high-level architecture (part 1)
</h3>

<img
src="https://miro.medium.com/max/2000/1*YvHp_ilnXq1s-C4AiGLnXg.png"
class="head"
/>

<p>
	To me, a browser was a black box. It eats my HTML, CSS, and JavaScript files,
	and displays a page. Somehow, it works.
</p>
<p>Until one day, I decided to sit down and find out why.</p>
<p>
	When searching online, I cannot find much information. Tali Garsiel has put
	together
	<a
	href="https://www.taligarsiel.com/Projects/howbrowserswork1.htm"
	target="_blank"
	rel="noopener nofollow"
	>a well-written one</a
	>
	in 2011. Since then, the browser architecture has changed. Chrome has taken
	over about 65% of market share with its Blink engine, forking from WebKit in
	2013. In the next 6 years, Chrome had evolved into a different architecture.
</p>
<p>
	However, the essential part of browsers has not changed much. They are all
	based on processes and threads.
</p>
<img src="https://miro.medium.com/max/1932/1*_pXb3gXK3HBK1y49Wecs4g.png" />
<p>
	Open a website with Chrome, and take a look at its
	<a
	href="https://www.wikihow.com/Open-Google-Chrome-Task-Manager"
	target="_blank"
	rel="noopener nofollow"
	>task manager</a
	>. You can see a list of processes currently running.
</p>
<p>
	Why it has so many processes with merely one tab open? That’s the question to
	decipher the black box.
</p>
<h1>Processes and threads</h1>
<img src="https://miro.medium.com/max/4044/1*2BC22n-JaF9su5X6khM2SA.png" />
<p>Threads are living in a process, along with data, codes, and files.</p>
<p>
	In a single-threaded process, well, there is only one thread. It is also the
	main thread of the process. A thread is a queue, processing tasks one by one.
	The next task has to wait until the earlier ones finish.
</p>
<p>
	What is the risk? If one task has a problem and crashes, the whole thread
	stops, and it leads to the termination of the entire process.
</p>
<img src="https://miro.medium.com/max/4220/1*FLz6mjMIqmFMMR8i6k9buw.png" />
<p>
	In a multi-threaded process, the tasks can process faster in multiple threads
	simultaneously. All threads share the data in the memory.
</p>
<p>If one of the threads stops, the process is terminated and exists.</p>
<h1>Browser in early age</h1>
<img src="https://miro.medium.com/max/3160/1*letGd3tL4ziLQ5hyHYRVdg.png" />
<p>
	Before modern browsers exist, we used the single-process browser. IE6 was the
	most popular one.
</p>
<p>
	There were no tabs in IE6. Each web page was allocated with a window because of
	the single-process limitation.
</p>
<p>
	In a single-process browser, the process needs to take care of everything,
	including page rendering, JavaScript execution, and more.
</p>
<p>
	This architecture brings three problems: instability, low performance, and
	insecurity.
</p>
<h2>Instability</h2>
<p>When a thread crashes, the process stops, and the whole browser freezes.</p>
<p>
	JavaScript and Flash plugin is famous for crashing page thread. When it
	happens, forcing the browser to exit is the only solution. That’s what happened
	to our IE6 experience.
</p>
<h2>Low performance</h2>
<p>
	Some JavaScript takes a while to finish. While executing the script, it blocks
	the page render thread. The browser has to wait until the script finishes
	execution and then proceed to display a page. The worst case is the infinite
	loop in JavaScript.
</p>
<p>
	Moreover, the memory leak can lead to the performance issue. The browser kernel
	is complex. The garbage collection sometimes doesn’t work correctly. The longer
	you use the browser, the more memory is taken from your system, you feel the
	browser has an increasingly longer response time.
</p>
<h2>Insecurity</h2>
<p>
	Evil plugins can easily gain access to your operating system with admin
	permission through the single-process browser. Besides, JavaScript can read
	sensitive information when you interact with the browser, like reading the
	input when you enter a password.
</p>
<p>
	What are the solutions? Developers made multiprocess browsers, also known as
	modern browsers.
</p>
<h1>Multiprocess browser</h1>
<img src="https://miro.medium.com/max/3636/1*kQeWXv3c0z_IqsL22CYLHw.png" />
<p>
	In a multiprocess browser, well, we have multiple processes. Between processes,
	they communicate with Inter-process communication (IPC). Each process runs
	various threads.
</p>
<img src="https://miro.medium.com/max/3252/1*gtICqjLOBfhULEeujuJbhw.png" />
<p>
	Nowadays, we have the following processes running in a browser:<br />- Browser
	process<br />- Renderer process<br />- Plugin process<br />- GPU process<br />-
	Network process<br />- Device process<br />- Video process (one of the utility
	processes)<br />- Audio process (one of the utility processes)
</p>
<p>
	It seems a lot, but let’s take a look at three essential ones: browser process,
	renderer process, and plugin process.
</p>
<p>
	Here is an illustration of the processes and their “territory” on a browser.
</p>
<img src="https://miro.medium.com/max/2320/1*9kqxiGaFtvxCIxU7zJ-PQA.png" />
<p>
	There are two significant changes in the multiprocess architecture.<br />-
	Separating the renderer and plugin process from the browser process.<br />-
	Placing renderer and plugin processes in sandboxes.
</p>
<p>
	Let’s see how these changes solve the problems in a single-process browser.
</p>
<h2>Fight against the instability</h2>
<p>
	Modern browsers put renderer and plugin processes separate from the browser
	process.
</p>
<p>
	The renderer process takes care of the page rendering and JavaScript execution.
	When it crashes, only the corresponding browser tab stops. You can still browse
	other tabs because the browser process remains intact.
</p>
<p>
	This separation treatment applies to the plugins as well. Each plugin has a
	separate process. For example, if the Flash plugin crashes, it doesn’t affect
	your browsing experience anymore.
</p>
<h2>Improve the low performance</h2>
<p>
	Each tab has a separate renderer process. When we open multiple tabs, the
	browser creates multiple renderer processes.
</p>
<p>
	JavaScript from different pages are running in their own renderer process. If
	one of the pages has a JavaScript issue blocking its process, the problem does
	block page rendering in other tabs. Multiple plugin processes help in the same
	way.
</p>
<p>
	How about the memory leak? Closing a tab triggers the garbage collection. All
	memory was taken will be released by the system.
</p>
<h2>Security with sandboxing</h2>
<p>
	All high-risk components are moved to the renderer process and running in a
	sandbox, including HTML parsing, JavaScript virtual machine, and Document
	Object Model (DOM).
</p>
<p>
	Meanwhile, system functionality is placed in the browser process, including
	persistence storage, user interaction, and networking.
</p>
<p>
	Vicious codes in renderer and plugin processes are difficult to touch your
	operating system.
</p>
<p>
	For example, a renderer process or plugin process cannot request resources from
	the network and file system directly in a sandbox. The browser process will
	take care of the request, and makes sure to proceed in a secure method.
</p>
<p>
	Here is a full list of what renderer process and browser process doing from
	<a
	href="http://seclab.stanford.edu/websec/chromium/chromium-security-architecture.pdf"
	target="_blank"
	rel="noopener nofollow"
	>The Security Architecture of the Chromium Browser</a
	>.
</p>
<p>
	The renderer process takes care of<br />- HTML parsing<br />- CSS parsing<br />-
	Image decoding<br />- JavaScript interpreter<br />- Regular expressions<br />-
	Layout<br />- Document Object Model<br />- Rendering<br />- SVG<br />- XML
	parsing<br />- XSLT
</p>
<p>
	The browser process takes care of<br />- Cookie database<br />- History
	database<br />- Password database<br />- Window management<br />- Location
	bar<br />- Safe Browsing blacklist<br />- Network stack<br />- SSL/TLS<br />-
	Disk cache<br />- Download manager<br />- Clipboard
</p>
<h1>Latest improvements on the browser architecture</h1>
<h2>Site isolation</h2>
<p>
	In 2018, Chrome released [site isolation](<a
	href="https://www.chromium.org/Home/chromium-security/site-isolation"
	target="_blank"
	rel="noopener nofollow"
	>https://www.chromium.org/Home/chromium-security/site-isolation</a
	>) feature to protect the users from security bugs.
</p>
<p>
	A cross-site iframe used to share the same renderer process on the page,
	meaning it has access to the same memory space. With
	<a
	href="https://developers.google.com/web/updates/2018/02/meltdown-spectre"
	target="_blank"
	rel="noopener nofollow"
	>Meltdown and Spectre</a
	>, cross-site iframes could bypass the
	<a
	href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy"
	target="_blank"
	rel="noopener nofollow"
	>Same Origin Policy</a
	>.
</p>
<img src="https://miro.medium.com/max/3444/1*M4W3oEmi-qqe1cOTaAQzNw.png" />
<p>
	Since Chrome 67, all cross-site iframes get a stand-along renderer process. In
	2019, Firefox starts
	<a
	href="https://wiki.mozilla.org/Project_Fission"
	target="_blank"
	rel="noopener nofollow"
	>Project Fission,</a
	>
	a project related to integrating the site isolation feature.
</p>
<h2>Same-site shares the renderer process</h2>
<p>
	Multiple renderer processes require more resources from your computer because
	each renderer process holds a copy of shared infrastructure in memory.
</p>
<p>
	In a way, these copies are redundant in memory. At the same time, they are the
	trade-off of security and performance. When you open 1,000 tabs in your
	browser, 1,000 renderer processes could cause performance issues.
</p>
<p>
	To minimize the performance impact, the browser tries to reuse an existing
	renderer process when you visit websites with the same domain.
</p>
<p>
	For example, when you visit the Medium website, your browser creates a renderer
	process for it. Then you click a link on the site which opens a new tab, the
	browser will reuse the same renderer process.
</p>
<p>
	This rule doesn’t apply when you manually open a new tab and entering a URL
	from the same domain. In this case, the browser creates a new renderer process
	for it.
</p>
<h2>Architecture in 2019 and the future</h2>
<p>Chrome now has more processes running separately.</p>
<p>
	Besides the browser, renderer, and plugin processes, the team has separated the
	GPU, networking, and utility processes from the browser process. That’s the
	reason we see many processes are running with merely opening one tab.
</p>
<p>
	By decoupling the processes, we made a faster and safer browser. The Chrome
	team decides to go further on this path.
</p>
<p>
	Service-Oriented Architecture was initialized by the Chrome team, introducing
	the Chrome Foundation Service in the architecture. It is a modular
	architecture.
</p>
<img src="https://miro.medium.com/max/3008/1*fq1ZJxwQKYiRf6LUtfJFdQ.png" />
<p>
	We have more processes in this architecture with sandboxes apply to most of
	them. More renderer processes mean taking more resources from your computer.
	The team also introduces graceful degradation when the laptop doesn’t have
	enough resources.
</p>
<p>
	SOA is a bold move and will take the team years to complete the change.
	Currently, the team is progressively improving the browser toward the SOA.
</p>
<h1>What is the takeaway?</h1>
<p>
	A browser is made of processes and threads. The complex browser mechanism is
	built on top of them.
</p>


<h3>
	How web browser works step by step in 2019 — high-level architecture (part 1)
</h3>

<img
src="https://miro.medium.com/max/2000/1*iLwDWX0ReDCbkYKSwQlFOw.png"
class="head"
/>

<p>In the last post, we know a web browser is made of all kinds of processes. It was a static view of a web browser architecture.</p>
<p>However, a browser is not static. It is proactively response to user interactions. When we interact with a browser, different processes start working together as a team and, finally, display a web page in front of us.</p>
<p>In this post, we will see how processes work together in navigation.</p>
<p>The navigation is the next black box we will dive in. The input is a URL, and the output is a web page.</p>


<h4>A high-level view of 5 steps</h4>

<p>Briefly, the 5 steps are:</p>

<ol>
	<li>Handling user input</li>
	<li>Sending a URL request</li>
	<li>Preparing a renderer process</li>
	<li>Committing navigation</li>
	<li>Rendering page</li>
</ol>

<img src="https://miro.medium.com/max/2000/1*jtAEpbwa_LVmdbgsDbG58g.png" alt="" />


<p>In these steps, three processes in the browser are involved:</p>
<ol>
	<li>The browser process handles user input (step 1). Also, it manages the other processes (step 3).</li>
	<li>A network process takes care of the URL request (step 2).</li>
	<li>A renderer process focuses on rendering a page (step 4 and 5).</li>
</ol>
<p>Navigation starts from step 2 to step 4.</p>
<p>More specifically, it starts when sending the URL request and ends when the browser starts rendering the page.</p>

<h4>Step 1: Handling user input</h4>

<p>Before navigation starts, a browser process parses the user input. More specifically, it is a UI thread in the browser process that does the job.
</p>

<img src="https://miro.medium.com/max/2000/1*tKjnhbMHuDnYuzJW6EhIaA.png" alt="" />

<p>Two possibilities exist when a user enters something in the address bar:</p>
<ol>
	<li>a search query, or</li>
	<li>A URL</li>
</ol>
<p>If the browser process believes the user input is a search query, it parses the keywords, composes a URL with the search query, then initials a URL request.</p>
<p>If it is a URL, for example, medium.com, the address bar attaches the protocol (HTTP or HTTPS) to it depending on the rules. With the protocol, the address bar now has a completed URL https://medium.com.</p>
<p>When the user hits the return, the browser process reads the URL from the address bar. It sends the URL request to a network process through inter-process communication (IPC).</p>
<p>At this moment, a “beforeunload” event is fired. The tab icon changes to a loading spinner. The web page remains the same.</p>

<h4>Step 2: Sending a URL request</h4>

<p>Now, a network process receives the command from the browser process to handle the URL request.</p>

<img src="https://miro.medium.com/max/1400/1*ZbGK2SEQ9QqE5Klsnw9r6A.png" alt="" />

<p>Before connecting to the internet, the network process first takes a look at the browser cache and see if the requested resource has been saved locally. If so, the network process returns the cached resource to the browser process.</p>
<p>If not, it starts connecting to the internet, initials a DNS lookup, receives the IP address, and establishes a TLS (Transport Layer Security) connection based on the IP address.</p>
<p>Finally, it sends the URL request to the server.</p>
<p>When receiving the request, the server generates a response based on the request, including response headers, response body, and other information. Finally, the server sends its response to the network process in our browser.</p>
<p>Now the network process starts parsing the response headers.</p>

<h5>Safe Browsing and CORB</h5>

<p>At this moment, Chrome checks the domain and response data, trying to match them with its malicious site database.</p>
<p>If there is a match, the network process alerts to the browser and displays a warning page.</p>
<p>Meanwhile, a Cross Origin Read Blocking (CORB) check happens to prevent side-channel attacks.</p>
<p>At this point, the network process may encounter different cases.</p>

<h5>Case 1 — redirection</h5>

<p>Depending on different status codes, the network process makes different choices. One of them is redirection.</p>
<p>If the network process sees 301 or 302 status codes in the response headers, it will initiate another URL request based on the correct address. The exact address is in the Location in the response headers.</p>
<p>The step will be repeated and starts with the DNS lookup again.</p>


<h5>Case 2 — Content-Type is not text/html</h5>

<p>Content-Type exists in the response headers, telling the network process the data type of the data in its response body.</p>
<p>The network process will decide how to react to the response body.</p>
<p>If the Content-Type is text/html, it tells the network process that the data is HTML.</p>
<p>If the Content-Type is application/octet-stream, it says the data is byte stream. Usually, the browser treats it as a download request, submits it to its download manager.</p>
<p>The navigation ends.</p>

<h5>Case 3 — status code is 200 and the Content-Type is text/html</h5>

<p>The network process continues navigation.</p>
<p>It tells the browser process that everything goes well, and it will start downloading the document data.</p>
<p>After receiving this message, the browser process moves to the next step and starts preparing a renderer process.</p>

<h4>Step 3: Preparing a renderer process</h4>

<img src="https://miro.medium.com/max/2000/1*AjwXe0spMClgE9KhBxuB1Q.png" alt="" />

<p>The browser process creates a renderer process, waiting for the ready signal from the renderer process.</p>
<p>Meanwhile, the network process is continuously downloading the document for the renderer process.</p>
<p>When the renderer process is in the standby position, the next step starts.</p>

<h4>Step 4: Committing navigation</h4>

<p>The browser process and the renderer process starts working together to replacing the old document with the new one.</p>

<img src="https://miro.medium.com/max/1400/1*_1DXcrFrl4ooLO7SykYSNw.png" alt="" />

<h5>More specifically, it has the following steps.</h5>

<ul>
	<li>When the render process is ready, it sends a “committing navigation” message to the browser process. The message notifies the browser process that the renderer process is prepared to parse document data.</li>
	<li>After receiving the message, the browser process starts clearing the old document.</li>
	<li>Then, a confirmation is sent from the browser process to the renderer process, letting it know that the commit has been completed.</li>
	<li>Meanwhile, the browser process updates its UI status.</li>
	<li>The renderer process receives confirmation and starts receiving the document from the network process.</li>
	<li>The renderer process confirms with the browser process that the document is committed.</li>
	<li>The navigation completes.</li>
</ul>

<h5>Regarding the status update in the browser process, it includes:</h5>

<ul>
	<li>safety status (the lock icon next to the URL)</li>
	<li>address bar URL</li>
	<li>history status (the forward and back buttons)</li>
	<li>web page (the old page is gone and turns white)</li>
	<li>store the session history on disk to facilitate the tab restore</li>
</ul>

<p>That’s why the previous page content stays for a bit when we enter a URL in the address bar. Until this point, the last page is removed.</p>
<p>When the renderer process receives the commit, it starts parsing data, requests downloading sub-resources, and other tasks. The navigation completes, and the page rendering phase begins.</p>

<h4>Step 5: Rendering page</h4>

<p>The renderer process receives confirmation. It carries on parsing the document data steamed from the network process and displays a page in front of you.</p>
<p>At the end of the rendering, the renderer process tells the browser process that the rendering is done.</p>
<p>The UI thread replaces the loading spinner in its tab with the favicon of the website. A `unload` event is fired.</p>

<h4>Network and storage threads are not relevant in 2019</h4>

<p>In a Google post, the network and storage threads were running in the browser process in 2018.</p>
<p>Based on the Chromium documentation, both have been separated and run as processes now.</p>
<p>Only when the environment doesn’t have enough resources, the browser gracefully degrades to previous architecture, in which the network and storage work as threads.</p>

<h3>What is the takeaway?</h3>

<img src="https://miro.medium.com/max/2000/1*eh8PkPsAj2USYXjHyfGaPQ.png" alt="" />

<h5>There are five steps to display a page:</h5>

<ul>
	<li>The browser process **handles user input**, compose a URL request.</li>
	<li>The networking process **sends a URL request**. The navigation starts.</li>
	<li>The browser process **creates a renderer process** after receiving a server response. The renderer process is in the standby position, and the network process received the document.</li>
	<li>The browser process **commits the navigation**. The network process starts sending document data to the renderer process. The navigation ends.</li>
	<li>The renderer process renders the document.</li>
</ul>


<h3>
	How does browser work step by step in 2019 — rendering phase (part 3)
</h3>

<img src="https://miro.medium.com/max/5224/1*5e0wIJccblDNqK6Z_N3qPQ.png" alt="" class="head" />

<p>
	In the last post, we see the navigation phase. Three processes work together
	to deliver the document for the next phase.
</p>
<p>
	In this post, we will open the box of the rendering phase and take a look at
	what is inside.
</p>
<h1>
	From document to web page — 8 sub-phases
</h1>

<img src="https://miro.medium.com/max/1934/1*nbAPgqYnaY9RzdeiEBtdaw.png" alt="" />

<h5>
	The rendering phase includes 6 sub-phases:
</h5>

<ol>
	<li>DOM construction</li>
	<li>Style computation</li>
	<li>Layout</li>
	<li>Layer</li>
	<li>Paint</li>
	<li>Tilling</li>
	<li>Raster</li>
	<li>Draw Quad and display</li>
</ol>

<h5>Two threads in the renderer process are involved in:</h5>

<ol>
	<li>The main thread takes care of the 1–5 phases</li>
	<li>The compositor thread manages the 6–8 phases</li>
</ol>


<img src="https://miro.medium.com/max/1400/1*7Eo7FDK3CCcbr8jFrtYtsg.png" alt="" />


<h4>Phase 1: DOM construction</h4>

<img src="https://miro.medium.com/max/1400/1*kIhpi0WmhwxMrSEndsIQeA.png" alt="" />

<p>The input is an HTML document carried over from the network process, and the output is a DOM tree.</p>
<p>Why DOM tree? A browser doesn’t speak HTML. The renderer process first needs to “translate” the HTML document to something a browser can understand.</p>
<p>That is the DOM tree.</p>

<h5>Let’s take a look at an example.</h5>

<pre>
	<code class="language-markup">
		&lt;html>
		&lt;body>
			&lt;h1>Hello world!&lt;/h1>
			&lt;div>
				&lt;p>
				It is a message from
				&lt;span>the web&lt;/span>
				&lt;/p>
			&lt;/div>
		&lt;/body>
		&lt;/html>
	</code>
</pre>

<img src="https://miro.medium.com/max/1400/1*k2UNk6hs2mN7iAAiVuDfbA.png" alt="" />

<p>The DOM tree of the example is shown in the image.</p>
<p>A DOM tree is a representation of HTML codes. We can visit it by entering the “document” in the Chrome console.</p>

<img src="https://miro.medium.com/max/1400/1*JJ_b1lLIkOW3MZrgVzJTMA.png" alt="" />

<p>The DOM tree exists in memory. Therefore, JavaScript can visit and edit it.</p>

<h4>Phase 2: Style computation</h4>

<img src="https://miro.medium.com/max/1400/1*RArKDVGue2N690j6XPfx2g.png" alt="" />

<p>The input is CSS styles, and the output is a computed style structure.</p>

<h4>It has three steps.</h4>

<h5>Step 1: “Translating” CSS</h5>

<p>Similar to HTML, the browser doesn’t speak CSS. The translated result is style sheets.</p>
<p>Entering “document.styleSheets” in the Chrome browser console, we can see all parsed style sheets.</p>
<p>These style sheets come from</p>

<ol>
	<li>a source linked in the <code>link</code> tag,</li>
	<li>styles inside of a <code>style</code>, and</li>
	<li>inline styles</li>
</ol>

<p>Same as a DOM tree, the style sheets look like a JavaScript object structure and can be visited and edited in the memory.</p>

<img src="https://miro.medium.com/max/1984/1*ilEydC4p18EeFJRp1j_JhQ.png" alt="" />

<p>Let’s take the Medium homepage as an example. It has 11 style sheets. The first one comes from a <code>link</code> tag, while the rest of them are styles inside of a <code>style</code> tag.</p>

<h5>Step 2: standardizing values and unites</h5>

<p>We use all kinds of values and units in our CSS.</p>

<ol>
	<li><code>width: 50%</code></li>
	<li><code>padding: 2em 0</code></li>
	<li><code>font-size: 1rem</code></li>
</ol>

<p>They are relative values.</p>
<p>At this step, all relative values are converted to the absolute ones, pixels.</p>
<p>Why pixels? At the end of the rendering phase, a browser displays bitmaps on the screen. Bitmaps are made of pixels.</p>
<p>It is time to do our math.</p>

<p>At the end of the standardization, the previous CSS values are changed to the following:</p>

<ol>
	<li><code>width: 500px</code> (Assuming the width of its parent element is 1000px.)</li>
	<li><code>padding: 32px 0</code> (Assuming the font size of the element is 16px.)</li>
	<li><code>font-size: 16px</code> (Assuming the font size of the root element is 16px.)</li>
</ol>

<h5>Step 3: style computation</h5>

<img src="https://miro.medium.com/max/1400/1*NY-Ti0ZX3q1dDFhoFrTY5Q.png" alt="" />

<p>Finally, the renderer process calculates the computed styles and attaches them to each element.</p>
<p>Why computing style? CSS stands for Cascading Style Sheets. Cascading means that an element inherits some styles from its ancestors, and overrides parts of them with its own.</p>
<p>The renderer process computes all styles based on the cascading rules. Then it generates a list of final computed styles for each element.</p>
<p>For example, an element inherits the font-size: 16px from its ancestors. Itself has a font-size: 32px. The computed font-size style is font-size: 32px.</p>

<img src="https://miro.medium.com/max/1400/1*fXETDySomJ8D-2PUoFprEw.png" alt="" />

<p>The image shows the computed style list for a h2 element on the Medium homepage.</p>
<p>After calculation completed, the final result is a list of computed styles. We can take a look at it in the Chrome console.</p>

<h3>Phase 3: Layout</h3>

<img src="https://miro.medium.com/max/1400/1*QTZ5-AsuNxA8ev8zg3WtSw.png" alt="" />

<p>In this phase, the inputs are the DOM tree and computed styles. The output is a layout tree with computed layout information.</p>

<h5>Step 1: constructing the layout tree</h5>

<p>The layout tree looks like a duplication of the DOM tree.</p>
<p>What are the differences? First of all, “invisible” elements in the DOM tree won’t be included in the layout tree.</p>
<p>For example, an element with display: none is excluded from the layout tree. Same as all elements inside of the <code>header</code> tag. There is an exception: an element with visibility: hidden; is in the layout tree.</p>
<p>Secondly, some CSS properties add content to the layout.</p>
<p>Take a pseudo-class, for example, <code>div::after {content: ‘I’m here’;}</code> creates a content included in the layout tree though it is not existing in the DOM tree.</p>

<h5>Step 2: calculating the geometry information</h5>
<p>To paint a box on a blank canvas, we need to know:</p>

<ol>
	<li>the starting x, y coordinates, and</li>
	<li>the size of the box</li>
</ol>

<p>Each element in the layout tree is a box.</p>

<p>Calculating the final geometry of each element is a mighty job. Think about it. In CSS, many properties modify the geometry of an element.</p>

<ol>
	<li>float: left;</li>
	<li>width: 100px;</li>
	<li>display: absolute;</li>
	<li>and more…</li>
</ol>

<p>It is challenging to design an effective layout system to work with it. Developers on BlinkOn shared some knowledge with us if you are interested.</p>
<p>The main thread does the heavy lifting for us and completes all the calculations.</p>
<p>Now it has a layout tree. On the layout tree, each element has precise coordinates and size information.</p>

<h5>Phase 4: Layer</h5>

<img src="https://miro.medium.com/max/1400/1*sDGZGGc_WLxUXAFvL4-VIg.png" alt="" />

<p>A layer three is about layers.</p>
<p>We all love the 3d transforming effect and convenient <code>z-index</code> property in CSS. They are all related to the layer.</p>
<p>If you ever use Photoshop or Sketch, you much be familiar with layers. The layer in a browser has the same concept.</p>
<p>Meanwhile, a layer tree is about the painting order. Why do we care about the painting order?</p>
<p>For example, you have two overlapping elements, element A and element B. A has a <code>z-index: 9</code>, which is more significant than B without a <code>z-index</code> property. A will be displayed at the top of B. The renderer process paints B on the canvas first, then paint A on top of it. This is a painting order.</p>
<p>The painting order is critical for the accurate display of your webpage.</p>

<p>How does a layer tree look like?</p>

<img src="https://miro.medium.com/max/1400/1*WziN5fCf9mdWJ30AKJMNAg.png" alt="" />

<p>From the graphic, we can see not all elements have their own layer. Painting layers are expensive. For better performance, the renderer process only creates a layer when it is needed.</p>
<p>When is it needed? Two kinds of elements are considered by the renderer process.</p>

<h5>Elements with stacking context</h5>

<ol>
	<li>z-index</li>
	<li>position: absolute</li>
	<li>transform</li>
	<li>will-change</li>
</ol>

<p>The above are some CSS properties related to the stacking context. The renderer process creates a layer for the elements with any of these properties.</p>
<p>You can see a full list of the CSS properties affecting the layer tree on MDN document.</p>
<p>Chrome allows us to take a look at the layers on a webpage.</p>

<h4>Clipped elements</h4>

<p>A typical case of clipped elements is an overflowed text element.</p>
<p>Let’s say we have a 300px * 300px div. The long text in the div box overflows. When giving the box overflow: auto; We know the text becomes scrollable inside of the div.</p>
<p>When seeing the overflowed text element, the renderer process creates three layers.</p>

<ol>
	<li>One for clipped texts, which visible in the 300px * 300px area.</li>
	<li>One for the full-text content so you can scrolling through them.</li>
	<li>One for scroll bar</li>
</ol>

<p>it is easier to understand this mechanism by viewing it in the console.</p>

<p>Run the following HTML in Chrome.</p>

<pre>
	<code class="language-markup">
		&lt;html>
		&lt;body>
		&lt;h1>Hell world!&lt;/h1>
			&lt;div class=“box” style=“width: 300px; height: 300px; overflow: auto;”>
				&lt;p>Lorem ipsum vel viverra elementum ut et parturient placerat curae at vestibulum ullamcorper a ullamcorper mattis nascetur ullamcorper ut mollis rhoncus sed parturient in vestibulum vestibulum. Leo nec nisi nec erat a purus aliquam habitasse a sem id nisi ullamcorper viverra suspendisse mollis fringilla a dis a suspendisse parturient a. A commodo scelerisque mi dictum non orci suspendisse felis velit dapibus a sit facilisis velit mi libero ultrices leo consectetur tempus montes quis consequat condimentum a ullamcorper amet. Donec orci fames id consectetur nascetur parturient et magnis nunc lacinia aliquet nec dolor dictumst conubia a hac nibh consectetur habitant vel a cras.&lt;/p>
			&lt;/div>
		&lt;/body>
		&lt;/html>
	</code>
</pre>

<p>Open the layer panel and take a look. Layers are displayed in the layer panel. Try scrolling the text in the box, you will get the idea.</p>

<img src="https://miro.medium.com/max/1400/1*4Y-TsGADWrFNtgz7J_DByQ.png" alt="" />

<p>Finally, after all the computation, the renderer process has the layer tree on hand.</p>

<h4>Phase 5: Paint</h4>

<img src="https://miro.medium.com/max/1400/1*VsBMUif0xXab_abwoH4MQQ.png" alt="" />

<p>In this phase, the inputs are the layout tree and layer tree, and the output is paint records.</p>
<p>How does a paint record look like?</p>
<p>It has three parts:</p>

<ol>
	<li>Action</li>
	<li>Position, including the coordinates (x, y) and the size (width, height).</li>
	<li>Styles</li>
</ol>

<p>For example, a paint record looks like the following:</p>

<ol>
	<li>Action: Draw Rect</li>
	<li>Pos: 0, 0, 300, 300</li>
	<li>backgroundColor: red</li>
</ol>

<p>It is a paint record to draw a 300px * 300px red rectangular at (0, 0).</p>
<p>A paint record is like a note for the browser to execute the painting.</p>
<p>The paint records are a list of these notes in an order we confirmed in the layer tree, like “background first, then rectangle, then text”.</p>
<p>In the next step, the compositor thread carries over the work from the main thread, starts generating bitmaps based on the paint records.</p>

<h4>Phase 6: Tilling</h4>

<img src="https://miro.medium.com/max/1400/1*FPp0xsMA0DxBi6-H52EdJw.png" alt="" />

<p>The input are the paint records and layers, and the output is tiles.</p>
<p>When tiling, the layers are separated into tiles, and the browser priorities the rendering based on the viewport position.</p>
<p>There are three keywords here: layer, tile, and viewport.</p>
<p>Let’s take a look at the Medium home page as an example. From Layer panel in DevTools, we can tell it has three layers:</p>

<ol>
	<li>document</li>
	<li>header</li>
	<li>scroll bar</li>
</ol>

<img src="https://miro.medium.com/max/1400/1*smMuLwoxsJs6nQOKpsoVOw.png" alt="" />

<p>The “document” layer is separated into tiles. Usually, a tile size is 256px * 256px or 512px * 512px.</p>

<img src="https://miro.medium.com/max/1400/1*XGZwU1k7U5SwCMqo1WRABQ.png" alt="" />

<p>Rendering all tiles are expensive. The visible tiles, which are currently in the viewport, have the priority.</p>

<h4>Phase 7: Raster</h4>

<img src="https://miro.medium.com/max/1400/1*E8HXfGqeBgnfsbHf3qsXFg.png" alt="" />

<p>The input is tiles, and the output is bitmaps.</p>
<p>After knowing the tiles, the compositor thread creates a raster threads pool. Multiple raster threads carry on rastering tiles simultaneously.</p>

<img src="https://miro.medium.com/max/1400/1*lwPXUr2sxC7WLB71RrQOAQ.png" alt="" />

<p>To accelerate the process, the raster threads send tiles to the GPU process through IPC. Then the GPU process generates bitmaps from tiles and saving bitmaps in GPU memory.</p>
<p>When the bitmaps are ready, GPU process delivers them back to the compositor thread in the render process for the next step.</p>

<h4>Phase 8: Draw Quad and Display</h4>

<img src="https://miro.medium.com/max/1400/1*rp2TRrXM4d-_2Pr0qfkwpg.png" alt="" />

<p>The input is bitmaps, and the output is a compositor frame.</p>
<p>When all needed tiles are processed, the compositor thread sends a command called Draw Quad to the browser process.</p>
<p>Inside of the browser process, a “viz” component receives the Draw Quad command, executes Display Compositor command, and “draws” a compositor frame into our computer memory.</p>

<img src="https://miro.medium.com/max/1400/1*52K23UgnVN9Z-bwe6tfdOQ.png" alt="" />

<p>Finally, the browser process displays the compositor frame in the browser.</p>
<p>It is impressive that the entire 8 phases are happening within 1/60 second in a modern browser. That is 16.67 milliseconds.</p>

<h3>What is the takeaway?</h3>

<img src="https://miro.medium.com/max/1400/1*3NRQcXczIankRLLph-dUdw.png" alt="" />

<h5>8 phases of rendering:</h5>

<ol>
	<li>The main thread in the renderer process “translates” the HTML document to DOM tree</li>
	<li>It conveys CSS into the computed style</li>
	<li>It creates a layout tree based on the DOM tree and computed style</li>
	<li>From a layout tree, it generates a layer tree</li>
	<li>Lastly, it establishes paint records</li>
	<li>The compositor thread carries over the paint records, starts tilling based on the current viewport</li>
	<li>Multiple raster threads raster tiles into bitmaps with the help of the GPU process.</li>
	<li>The browser process receives the Draw Quad command from the browser process, then it displays a frame of the page in front of us.</li>
</ol>


<h3>How does browser work stepby stepin 2019 — optimization in the loading stage (part 4)</h3>


<p>What is the point of knowing how a browser works? We can improve performance with confidence.</p>
<p>When using a browser, usually, we open a URL, interact with the page, and close the tab when getting what we need.</p>
<p>These are three stages during the entire interaction between a user and a browser:</p>
<ol>
	<li>Loading stage — it starts when we enter a URL.</li>
	<li >Interaction stage — it begins when we can browse, click, and interact with the page.</li>
	<li >Closing stage — it starts when we click the close button on a tab.</li>
</ol>
<p>The web front-end optimization focus on the <strong>loading and interaction stages</strong>.</p>
<p>From the navigation to rendering phases, the critical optimization point is the DOM construction phase. Many factors could block the HTML parsing and prolong the entire rendering phase. When it happens, we, as a user, have to stare at a white screen for a while.</p>
<h1 >DOM construction blocking</h1>
<p>We focused on the rendering phases and skipped some details of the HTML parsing in the last post.</p>
<p>HTML document contains more than HTML, including CSS styles and JavaScript files. Both could block DOM construction and reduce web performance.</p>
<h2 >How JavaScript blocks the DOM construction?</h2>
<p>Let’s start with a simple example, an inline JavaScript.</p>
<img src="https://miro.medium.com/max/3168/1*8LqzSP2ZNnZfz7ARgpd7ZQ.png" alt="" />

<p>In the example, the script replaces the inner text of an element. It modifies the DOM tree.</p>
<img src="https://miro.medium.com/max/4696/1*6D7h2KM9iNxrdKq0F9o6Iw.png" alt="" />

<p>HTML parser is responsible to “translate” the HTML document. When seeing the JavaScript script, the HTML stops parsing the DOM and executes it immediately. When the execution completes, the HTML parser continues parsing the rest of the HTML document.</p>
<p>What if it is a JavaScript file linked to the script tag?</p>
<img src="https://miro.medium.com/max/3168/1*MOZD1TFOIpVCRY0b5VVZ6Q.png" alt="" />
<img src="https://miro.medium.com/max/4748/1*17Bvi0k3fmqBiFI3cdBJIQ.png" alt="" />


<p>When seeing the linked script file, again, the HTML parser stops DOM tree construction. Meanwhile, the renderer process communicates to the network process, asking to download the JavaScript file from the server. When the network process delivers the data, the renderer process executes the script before continuing to parsing the HTML file.</p>
<p>The download process increases the time to construct the DOM tree on topof the time the browser executes JavaScript.</p>
<h2 >How CSS blocks the DOM construction?</h2>
<p>CSS along doesn’t block the DOM construction. It does when combining with JavaScript.</p>
<img src="https://miro.medium.com/max/3168/1*SoulSotCXmXqARpg5-B5VA.png" alt="" />

<p>In this case, a CSS style file is referenced in the HTML, and JavaScript modifies the style in the “styles.css” file.</p>
<p>The renderer process needs to have <strong>computed style</strong> ready before executing the JavaScript to modify the styles. Therefore, the HTML parser cannot continue until the CSS file is parsed, and the JavaScript file execution is completed.</p>
<img src=""https://miro.medium.com/max/3648/1*xJgk0n5ku70e2FOBGLyCPA.png"" alt="" />
<p>When developing a website, it is inevitable to have linked files in our HTML document.</p>
<p>To accelerate the process, a <strong>preload scanner</strong> quickly scans the document data concurrently while building the DOM tree. If the preload scanner finds any linked files, for example, CSS and JavaScript files, it creates an IPC connection to the network process and requests the data from the server.</p>
<p>When does the renderer process resume the DOM structuring? It depends on the file taking the most extended length of download time.</p>
<p>Let’s say two files need to be downloaded. One file takes 1 second, and the other takes 3 seconds. The total is 3 seconds.</p>
<h1 >Optimization in the loading stage is about reducing the download time</h1>
<p>When building the DOM tree, The most time-consuming parts are downloading linked files and executing JavaScript.</p>
<h2 >Key indicator — round-tripdelay time (RTD)</h2>
<p>When it comes to optimization, we need a key indicator to measure it, so we know if the solution works.</p>
<p><a href="https://en.wikipedia.org/wiki/Round-trip_delay_time" target="_blank" rel="noopener nofollow">Round-tripdelay time (RTD)</a> or round-triptime (RTT) is a general term in telecommunications measuring the length of time it takes to send and receive a signal.</p>
<p>In our context, the time measurement starts when the network process sends a request to a server and ends when it receives the complete confirmation from the server. RTD is the total length of the time it takes to complete this process.</p>
<p>Because of the features of TCP, the data is sent in chunks. Take a CSS file, for example, the size is 0.1M. The size of each chunked data pack sent through HTTP, usually, is around 14KB. A 0.1M file is divided into 8 packs. We can say the CSS file takes 8 RTD to complete.</p>
<p>How about downloading two files? One CSS file is 9KB, so it takes 1 RTD to download. Another JavaScript file is 15KB taking 2 RTD to complete downloading. Since the download happens parallel, the total time is 2 RTD.</p>
<p>The calculation here is not entirely accurate because we ignore the TCPconnection time and the server response time, but you get the idea.</p>
<p>With RTD in mind, now we can talk about the optimization:</p>
<ol>
	<li>Reduce the number of key resources</li>
	<li >Minimize the size of key resources</li>
</ol>
<h2 >Reduce the number of key resources</h2>
<p>What are the key resources? Any CSS and JavaScript files are required when loading a page. Without them, your website is broken.</p>
<p>To reduce the linked files, we can move essential CSS and JavaScript data directly in the HTML file to avoid the download process.</p>
<p>If some linked JavaScript files don’t morph the DOM tree and styles, mark them with “defer” and/or “async,” so they don’t block the DOM construction.</p>
<p>A deferred script executes when the DOM is ready but before the “DOMContentLoaded” event. An async script is independent of other scripts and events. It runs as soon as it is available.</p>
<p>Some believe that it helps to separate a large CSS file into smaller ones based on media queries. It is not entirely true. A stylesheet with a media query attached to its &lt;link&gt; tag will still download even if the query returns false. It is just the content doesn’t apply the styles. Therefore, it doesn’t reduce the download requests.</p>
<h2 >Reduce the size of key resources</h2>
<p>Smaller file size means fewer RTD. We can achieve it by compressing CSS and JavaScript files. Moreover, most compression tools remove the comments in the data, which helps reduce the file size.</p>


<h3>How does browser work step by step in 2019 — optimization in the interaction stage (part 5)</h3>


<p>Optimization in the interaction stage is about optimizing the frames.</p>
<p>When interacting with the page, a user triggers events. Some events modify the page layout and styles. Depending on the scripts, the browser may need to go through the rendering stage multiple times to continuously deliver new bitmaps or compositor frames to our screen.</p>
<h3>FPS and lag</h3>
<p>Human eyes can see up to 1,000 frames per second (FPS). In slow or static scenes, we rarely tell the difference beyond 30 FPS. However, it becomes noticeable in dynamic scenes, such as playing first-person shooter video games. Today, most monitors refresh rate is 60 FPS or 60 Hertz.</p>
<p>Ideally, the browser needs to complete the rendering stage and deliver a frame within 1/60 seconds. That is 16.67 milliseconds. If so, a user sees a smooth animation and doesn’t feel lagging.</p>
<p>In the interaction stage, usually, a page update is triggered by executing JavaScript. Most of the time, it could trigger reflow and repaint.</p>
<h3>Reflow and repaint</h3>
<p>What happens when a line of JavaScript changes an element height?</p>
<p>The height modification doesn’t affect the DOM tree. Instead, it requires style computation.</p>

<img src="https://miro.medium.com/max/2482/1*zrJZsKLKGMklW7AXC4PNfA.png" alt="" />

<p>At the end of style computation, the renderer process reflects the height change to the layout phase, leading to the transformation of the element’s geometry information. Therefore, the layout tree needs to be generated. <br>The layout tree is the dependency of the remaining phases, so the renderer process needs to go through all steps.</p>
<p>This process is called <strong >reflow</strong>
.</p>
<p>Many attributes checking could trigger reflow when called in JavaScript like “element.offsetLeft.” Here is <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a"  target="_blank" rel="noopener nofollow">a full list of them</a>
.</p>

<img src="https://miro.medium.com/max/2496/1*8dSEt221agvUtqI8LtzTbw.png" alt="" />

<p>The worst case of the reflow is modifying DOM. An example is “document.body.appendChild(node).” The reflow process starts from the first phase, building the DOM tree.</p>
<p>How about changing the background color of an element?</p>

<img src="https://miro.medium.com/max/2548/1*PBKRxCH7FictAyRRbUSJtw.png" alt="" />

<p>Again, let’s start with the style computation. The new background color doesn’t modify the element’s geometry information, so the renderer process skips it. It doesn’t create a new layer either, so let’s skip the layer phase. At the paint phase, the renderer process needs to generate a new paint record to reflect the background color update. Then, it goes through the rest of the phases.</p>
<p>This process is called <strong >repaint</strong>
.</p>
<p>Both reflow and repaint lower the rendering performance for two reasons:</p>
<ul ><li>The reflow and repaint process is happening in the main thread, so it cannot take care of any events triggered by users’ interaction. When it happens, the users feel lagging.</li>
	<li>The computation process in the layout, layer, and paint phases are expensive.</li>
</ul>
<p>Since the repaint skips the layout and layer phases, it is a relatively better option than reflow.</p>
<h3>Are there any changes that don’t trigger reflow and repaint at all?</h3>
<p>Yes. CSS animation is an excellent example.</p>

<img src="https://miro.medium.com/max/2526/1*fZWTOzd1sDzFyJqwUmcegw.png" alt="" />

<p>A typical CSS animation uses a “transform” property. Modifying “transform” value skips the layout, layer, and paint phases, and starts with the tilling in the compositor thread.</p>
<p>Without occupying the main thread, CSS animation doesn’t block users’ interaction. It is the reason that you still see smooth CSS animation even if the page freezes.</p>
<h3>Optimization in the interaction stage is about increasing the speed of frame generation</h3>
<p>JavaScript execution, reflow, and repaint could slow down the frame generation.</p>
<p>When executing, JavaScript are running in the main thread. The idea here is to use the main thread as little as possible.</p>
<h4>Reduce the length of time executing JavaScript</h4>
<p>For example, a significant function could take hundreds of milliseconds to complete. It blocks the main thread and lowers the performance.</p>
<p>We can separate the function to smaller ones, so each of them doesn’t take long. The browser helps optimize the tasks when running the functions.</p>
<p>Web Worker is another option. You can operate it as an independent thread in the renderer process. When scripts run in the Web Worker, the main thread is free. If a piece of JavaScript is not visiting DOM and stylesheets, you can move it to the Web Worker.</p>
<h4>Avoid the reflow and repaint when executing JavaScript</h4>
<p>When the DOM tree is modified, the renderer process will recalculate the style and layout. Usually, the computation runs asynchronously in another task.</p>
<p>Let’s take a look at an example.</p>

<img src="https://miro.medium.com/max/1584/1*i6bGxhkdJcEMmpYrB6y-Xg.png" alt="" />

<img src="https://miro.medium.com/max/2334/1*tgBOxwgkQ4qgnpsQo9fA3w.png" alt="" />

<p>The first task completes the JavaScript execution. Then another task runs asynchronously to compute the style and layout.</p>
<p>What if we check the element height at the end of the script?</p>

<img src="https://miro.medium.com/max/1584/1*_3JldjZbqcJZaHW1MA6Jww.png" alt="" />

<p>When evaluating the element “offsetHeight,” the value is still the old one because the renderer process has not yet computed the style and layout. The renderer process starts the calculation synchronously so it can receive the updated value.</p>

<img src="https://miro.medium.com/max/2340/1*k4IclVcFZ6Ap1wFZcgpGFA.png" alt="" />

<p>In this case, we force the style and layout computation happening in the JavaScript execution task. The calculation blocks the main thread until the execution completes.</p>
<p>What is worse? We evaluate the attributes in a for-loop. The previous process happens continuously until the end of the execution. Most of the time, a noticeable delay occurs on the page.</p>
<p>In a real-life project, it is hard to avoid evaluating the attributes entirely. However, we can try to minimize usage.</p>
<h4>Using CSS animation and “will-change”</h4>
<p>CSS animation doesn’t use the main thread at all, so we can use it as much as possible.</p>
<p>Meanwhile, we can attach the “will-change” attribute to the animated elements. An element with a “will-change” is rendered on a stand-along layer in the layer tree, further optimizing the frame generation in the compositor thread.</p>















































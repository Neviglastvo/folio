<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Cheats (gulp)</title>
		<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#fff" />
		<meta name="format-detection" content="telephone=no" />
		<link rel="stylesheet" media="all" href="css/roadmap.css" />
		</link>
	</head>
	<body>
		<!-- BEGIN content -->
		<div class="roadmap">
			<div class="roadmap__left">
				<div class="roadmap__list">
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content="basics"> Основы </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsHowInternetWorks"> Как устроен интернет </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsHowWebWorks"> Как устроен WEB </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basics"> Как работает браузер </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsHttpCodes"> HTTP Status codes </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsHowInternetWorks"> Semantic HTML </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsCookies"> Cookies </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsWebStorage"> Web Storage </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="basicsHowInternetWorks"> Basic SEO </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content="basicsHowInternetWorks"> Accessibility </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content="js"> JavaScript </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsEnginesV8"> EnginesV8 </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsJSON"> JSON </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsSyntax"> Syntax </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsScroll"> Scroll </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsStorage"> Storage </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsObjects"> Objects </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsArrays"> Arrays </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsRegExp"> Regular Expressions </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsDataTypes"> Data Types </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsThis"> This </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsEventLoop"> Event Loop </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsHoisting"> Hoisting </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsClosures"> Closures </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsTryCatch"> Try/Catch </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsPromises"> Promises </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsAsync"> Async/Await </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsFetch"> Fetch </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsAxios"> Axios </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsArrayReduce"> Array Reduce </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsES6"> ES6 </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsModules"> ES6 Modules </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsNumbers"> Numbers </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="jsDOM"> DOM </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="js"> Fetch API / Ajax </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="js"> ES6+ and modules </div>
						<div class="roadmap__item-secondary roadmap-learned roadmap__item-secondary--overlay js-item" data-content="js"> Language concepts <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Hoisting </div>
								<div class="roadmap__item-overlay-item"> Event Bubbling </div>
								<div class="roadmap__item-overlay-item"> Scope </div>
								<div class="roadmap__item-overlay-item"> Prototype </div>
								<div class="roadmap__item-overlay-item"> Shadow Dom </div>
								<div class="roadmap__item-overlay-item"> strict </div>
								<div class="roadmap__item-overlay-item"> how browsers work </div>
								<div class="roadmap__item-overlay-item"> DNS </div>
								<div class="roadmap__item-overlay-item"> HTTP </div>
							</div>
						</div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content="html"> HTML </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="htmlBasics"> Basics </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="htmlBasics"> Semantic HTML </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content="htmlBasics"> Basic SEO </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content="htmlBasics"> Accessibility </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> CSS </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Basics </div>
						<div class="roadmap__item-secondary roadmap-learned roadmap__item-secondary--overlay js-item" data-content=""> Layouts <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Floats </div>
								<div class="roadmap__item-overlay-item"> Positioning </div>
								<div class="roadmap__item-overlay-item"> Display </div>
								<div class="roadmap__item-overlay-item"> Box Model </div>
								<div class="roadmap__item-overlay-item"> CSS Grid </div>
								<div class="roadmap__item-overlay-item"> Flex Box </div>
							</div>
						</div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> CSS3 </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Media-Queries </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Crossbrowser </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Imports, variables </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Package Managers </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> npm </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> yarn </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> CSS Preprocessors </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> SASS </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> PostCSS </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Less </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> CSS Frameworks </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> Bootstrap </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> Materialize CSS </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> Bulma </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> Semanit UI </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> CSS Architecture </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> BEM </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> OOCSS </div>
						<div class="roadmap__item-secondary roadmap-knowABit  js-item" data-content=""> SMACSS </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Build tools </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Gulp </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Webpack </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> ESLint </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> JS Framework </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> React.js </div>
						<div class="roadmap__item-secondary roadmap-learning  js-item" data-content=""> Vue.js </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Angular </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> CSS in JS </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Styled Components </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> CSS Modules </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Emotion </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Radium </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Glamouros </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Testing apps </div>
						<div class="roadmap__item-secondary roadmap-forFuture roadmap__item-secondary--overlay js-item" data-content=""> types <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Unit </div>
								<div class="roadmap__item-overlay-item"> Integrational </div>
								<div class="roadmap__item-overlay-item"> Functional </div>
							</div>
						</div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Jest </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Enzyme </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Cypress </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Mocha </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Karma </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Jasmine </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> PWA </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Storage </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Web Sockets </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Service Workers </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Location </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Notification </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Device Orientation </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Payments </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> Credentials </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> App performance </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> PRPL Patterns </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> RAIL Model </div>
						<div class="roadmap__item-secondary roadmap-learning  js-item" data-content=""> Performance Metrics </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Light House Metrics </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Dev Tools mastering </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Type Checkers </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> TypeScript </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Flow </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Server Side Rendering </div>
						<div class="roadmap__item-secondary roadmap-forFuture roadmap__item-secondary--overlay js-item" data-content=""> React.js <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Next.js </div>
								<div class="roadmap__item-overlay-item"> After.js </div>
							</div>
						</div>
						<div class="roadmap__item-secondary roadmap-learning roadmap__item-secondary--overlay js-item" data-content=""> Vue.js <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Universal </div>
							</div>
						</div>
						<div class="roadmap__item-secondary roadmap-shit roadmap__item-secondary--overlay js-item" data-content=""> Angular <div class="roadmap__item-overlay">
								<div class="roadmap__item-overlay-item"> Nuxt.js </div>
							</div>
						</div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Static Site Generators </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Gatsby.js </div>
						<div class="roadmap__item-secondary roadmap-learned  js-item" data-content=""> Nunjucks </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Desktop Apps </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Electron </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Proton Native </div>
						<div class="roadmap__item-secondary roadmap-shit  js-item" data-content=""> Carlo </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Mobile Apps </div>
						<div class="roadmap__item-secondary roadmap-forFuture  js-item" data-content=""> React Native </div>
						<div class="roadmap__item-secondary roadmap-  js-item" data-content=""> Native Script </div>
					</div>
					<div class="roadmap__item">
						<div class="roadmap__item-main js-item" data-content=""> Keep Learning </div>
					</div>
				</div>
				<div class="roadmap__legend">
					<div class="roadmap__legend-item">
						<div class="roadmap__legend-text">learned and used</div>
						<div class="roadmap__legend-color roadmap-learned"></div>
					</div>
					<div class="roadmap__legend-item">
						<div class="roadmap__legend-text">learning now</div>
						<div class="roadmap__legend-color roadmap-learning"></div>
					</div>
					<div class="roadmap__legend-item">
						<div class="roadmap__legend-text">reading about</div>
						<div class="roadmap__legend-color roadmap-knowABit"></div>
					</div>
					<div class="roadmap__legend-item">
						<div class="roadmap__legend-text">need to learn</div>
						<div class="roadmap__legend-color roadmap-forFuture"></div>
					</div>
					<div class="roadmap__legend-item">
						<div class="roadmap__legend-text">not interested</div>
						<div class="roadmap__legend-color roadmap-shit"></div>
					</div>
				</div>
			</div>
			<div class="roadmap__content">
				<div class="roadmap__content-item js-content" data-content="basics">
					<div class="roadmap__content-item-title">Основы</div>
					<div class="roadmap__content-text">
						<h3>Интернет — это много компьютеров</h3>
						<p> Интернет — это много вычислительных машин, которые объединены в сеть. Объединение в сеть означает, что одна вычислительная машина может отправить другой сообщение, а та может ответить. </p>
						<p> клиент делает запрос серверу, тот даёт ответ, и на клиенте выводится ответ </p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHowInternetWorks">
					<div class="roadmap__content-item-title">Как устроен интернет</div>
					<div class="roadmap__content-text"> asd </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHowWebWorks">
					<div class="roadmap__content-item-title">Как устроен WEB</div>
					<div class="roadmap__content-text">
						<h3>Клиенты и серверы</h3>
						<p>Компьютеры, подключенные к сети называются клиентами и серверами. Упрощенная схема того, как они взаимодействуют, может выглядеть следующим образом:</p>
						<img src="https://mdn.mozillademos.org/files/8973/Client-server.jpg" alt="" />
						<ol>
							<li>Клиенты являются обычными пользователями, подключенными к Интернету посредством устройств (например, компьютер подключен к Wi-Fi, или ваш телефон подключен к мобильной сети) и программного обеспечения, доступного на этих устройствах (как правило, браузер, например, Firefox или Chrome).</li>
							<li>Серверы - это компьютеры, которые хранят веб-страницы, сайты или приложения. Когда клиентское устройство пытается получить доступ к веб-странице, копия страницы загружается с сервера на клиентский компьютер для отображения в браузере пользователя.</li>
						</ol>
						<h5>Помимо клиента и сервера, мы также должны уделить внимание:</h5>
						<ol>
							<li><b>Ваше Интернет-подключение:</b> <br /> Позволяет отправлять и принимать данные по сети. Оно подобно улице между домом и магазином.</li>
							<li><b>TCP/IP:</b> <br /> Протокол Управления Передачей и Интернет Протокол являются коммуникационными протоколами, которые определяют, каким образом данные должны передаваться по сети. Они как транспортные средства, которые позволяют сделать заказ, пойти в магазин и купить ваши товары. В нашем примере, это как автомобиль или велосипед (или собственные ноги).</li>
							<li><b>DNS:</b> <br /> Система Доменных Имён напоминает записную книжку для веб-сайтов. Когда вы вводите веб-адрес в своем браузере, браузер обращается к DNS, чтобы найти реальный адрес веб-сайта, прежде чем он сможет его получить. Браузеру необходимо выяснить, на каком сервере живет сайт, поэтому он может отправлять HTTP-сообщения в нужное место (см. Ниже). Это похоже на поиск адреса магазина, чтобы вы могли попасть в него.</li>
							<li><b>HTTP:</b> <br /> Протокол Передачи Гипертекста - это протокол, который определяет язык для клиентов и серверов, чтобы общаться друг с другом. Он, как язык, который вы используете, чтобы заказать ваш товар.</li>
							<li><b>Файлы компонентов:</b> <br /> сайт состоит из нескольких различных файлов, которые подобны различным отделам с товарами в магазине. <br />
								<p><b>Эти файлы бывают двух основных типов:</b></p>
								<b>Файлы кода:</b> <br /> сайты построены преимущественно на HTML, CSS и JavaScript, хотя вы познакомитесь с другими технологиями чуть позже. <br /> <br />
								<b>Материалы:</b> <br /> это собирательное название для всех других вещей, составляющих сайт, такие как изображения, музыка, видео, документы Word и PDF.
							</li>
						</ol>
						<h4>Что же на самом деле происходит?</h4>
						<p>Когда вы вводите веб-адрес в свой браузер (для нашей аналогии - посещаете магазин):</p>
						<ol>
							<li>Браузер обращается к DNS серверу и находит реальный адрес сервера, на котором "живет" сайт (Вы находите адрес магазина).</li>
							<li>Браузер посылает HTTP запрос к серверу, запрашивая его отправить копию сайта для клиента (Вы идёте в магазин и заказываете товар). Это сообщение и все остальные данные, передаваемые между клиентом и сервером, передаются по интернет-соединению с использованием протокола TCP/IP.</li>
							<li>Если сервер одобряет запрос клиента, сервер отправляет клиенту статус "200 ОК", который означает: "Конечно, вы можете посмотреть на этот сайт! Вот он", а затем начинает отправку файлов сайта в браузер в виде небольших порций, называемых пакетными данными (магазин выдает вам ваш товар или вам привозят его домой).</li>
							<li>Браузер собирает маленькие куски в полноценный сайт и показывает его вам (товар прибывает к вашей двери — новые вещи, потрясающе!).</li>
						</ol>
						<h4>DNS</h4>
						<p>Реальные веб-адреса - неудобные, незапоминающиеся строки, которые Вы вводите в адресную строку, чтобы найти ваши любимые веб-сайты. Эти строки состоят из чисел, например: <code>63.245.215.20</code>.</p>
						<p>Такой набор чисел называется <a title='IP адрес - это число, назначенное каждому устройству, подключённому к сети, которая использует Интернет-протокол. Термин "IP адрес" обычно означает 32-разрядные IPv4 адреса, но до тех пор, пока IPv6 не получит более широкое применение.' href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/IP_Address">IP-адресом</a> и представляет собой уникальное местоположение в Интернете. Впрочем, его не очень легко запомнить, правда? Вот почему изобрели DNS. Это специальные сервера, которые связывают веб-адрес, который вы вводите в браузере (например, "mozilla.org"), с реальным IP-адресом сайта.</p>
						<h4>Пакеты</h4>
						<p>"Пакеты" - формат, в котором данные передаются от сервера к клиенту. Когда данные передаются через Интернет, они отправляются в виде тысячи мелких кусочков, так что множество разных пользователей могут скачивать один и тот же сайт одовременно. Если бы сайты отправлялись одним большим куском, тогда бы только один пользователь мог скачать его за один раз, и это, очевидно, сделало бы пользование интернетом не эффективным и не очень радостным.</p>
						<h4>На примере одного запроса</h4>
						<p>Допу­стим, вы&nbsp;захо­те­ли открыть глав­ную стра­ни­цу «Яндек­са». Вот как всё будет про­ис­хо­дить.</p>
						<p>Вы&nbsp;набра­ли в&nbsp;бра­у­зе­ре адрес yandex.ru. Опус­кая тех­ни­че­ские подроб­но­сти, ска­жем, что ваш бра­у­зер узнал, что сайт yandex.ru живёт на&nbsp;ком­пью­те­ре с&nbsp;адре­сом 77.88.55.80.</p>
						<p>77.88.55.80&nbsp;— это IP-адрес. Такой адрес есть у&nbsp;всех ком­пью­те­ров в&nbsp;интер­не­те, в&nbsp;том чис­ле у&nbsp;ваше­го. Ваш бра­у­зер гово­рит ком­пью­те­ру: «Сде­лай запрос на&nbsp;77.88.55.80».</p>
						<p>Ком­пью­тер упа­ко­вы­ва­ет этот запрос: ста­вит отмет­ку «от кого», «кому», фор­му­ли­ру­ет сам вопрос. Полу­ча­ет­ся такой пакет дан­ных. Он отправ­ля­ет этот пакет той коро­боч­ке, кото­рая сто­ит у&nbsp;вашей две­ри и&nbsp;мига­ет огонь­ка­ми.</p>
						<img class="alignnone wp-image-1163 size-medium" src="https://thecode.media/wp-content/uploads/2019/04/10_6-1024x681.jpg" alt="Как устроен интернет: Компьютер отправляет пакет данных маршрутизатору" width="1024" height="681" srcset="https://thecode.media/wp-content/uploads/2019/04/10_6-1024x681.jpg 1024w, https://thecode.media/wp-content/uploads/2019/04/10_6-320x213.jpg 320w, https://thecode.media/wp-content/uploads/2019/04/10_6-1080x718.jpg 1080w, https://thecode.media/wp-content/uploads/2019/04/10_6-768x511.jpg 768w, https://thecode.media/wp-content/uploads/2019/04/10_6.jpg 1456w" sizes="(max-width: 1024px) 100vw, 1024px">
						<p>Роу­тер смот­рит, что за&nbsp;адрес. Он&nbsp;видит, что ника­ких ком­пью­те­ров с&nbsp;таким адре­сом к&nbsp;это­му роу­те­ру не&nbsp;под­клю­че­но, поэто­му пере­да­ёт запрос более стар­ше­му роу­те­ру&nbsp;— на&nbsp;кры­ше подъ­ез­да.</p>
						<p>Роу­тер на&nbsp;кры­ше видит, что ника­ких ком­пью­те­ров с&nbsp;нуж­ным адре­сом к&nbsp;нему тоже не&nbsp;под­клю­че­но. Он&nbsp;отда­ёт запрос выше, на&nbsp;рай­он­ный роу­тер. Тот ещё выше, про­вай­де­ру.</p>
						<p>У&nbsp;про­вай­де­ра на&nbsp;роу­те­ре напи­са­на чёт­кая инструк­ция, что если при­дёт запрос на&nbsp;адрес 77.88.55.80, нуж­но пере­дать его вон тому роу­те­ру. Он&nbsp;это дела­ет. Мы&nbsp;ока­зы­ва­ем­ся на&nbsp;маги­страль­ном кана­ле, кото­рый при­ве­дёт запрос в «Яндекс».</p>
						<img class="alignnone wp-image-1164 size-medium" src="https://thecode.media/wp-content/uploads/2019/04/10_7-1024x681.jpg" alt="Как устроен интернет: От роутера к роутеру на&nbsp;магистральный канал" width="1024" height="681" srcset="https://thecode.media/wp-content/uploads/2019/04/10_7-1024x681.jpg 1024w, https://thecode.media/wp-content/uploads/2019/04/10_7-320x213.jpg 320w, https://thecode.media/wp-content/uploads/2019/04/10_7-1080x718.jpg 1080w, https://thecode.media/wp-content/uploads/2019/04/10_7-768x511.jpg 768w, https://thecode.media/wp-content/uploads/2019/04/10_7.jpg 1456w" sizes="(max-width: 1024px) 100vw, 1024px">
						<p>У «Яндек­са» тыся­чи сер­ве­ров, и&nbsp;один из&nbsp;них отве­ча­ет за&nbsp;глав­ную стра­ни­цу. Он&nbsp;полу­чил запрос через цепоч­ку роу­те­ров и&nbsp;теперь обра­ба­ты­ва­ет.</p>
						<p>Про­грам­ма на&nbsp;сер­ве­ре «Яндек­са» гото­вит ответ на&nbsp;запрос. Она смот­рит, из&nbsp;како­го горо­да к&nbsp;нему обра­ща­ют­ся, и&nbsp;ком­по­ну­ет ново­сти для это­го горо­да. Опре­де­ля­ет, зна­ет&nbsp;ли она это­го поль­зо­ва­те­ля, и&nbsp;если зна­ет&nbsp;— пока­зы­ва­ет ему чис­ло непро­чи­тан­ных в&nbsp;поч­то­вом ящи­ке. Ещё она совер­ша­ет мно­же­ство неви­ди­мых дей­ствий, что­бы опти­ми­зи­ро­вать стра­ни­цу.</p>
						<p>Код ито­го­вой стра­ни­цы про­грам­ма паку­ет по малень­ким паке­там и&nbsp;отда­ёт на бли­жай­ший роу­тер. На каж­дом паке­те напи­сан обрат­ный адрес, с&nbsp;кото­ро­го изна­чаль­но при­шёл запрос. Роу­тер начи­на­ет искать, как бы доста­вить эти паке­ты обрат­но. Он отправ­ля­ет их на маги­страль, там роу­те­ры пере­да­ют эти паке­ты про­вай­де­ру, он их направ­ля­ет в&nbsp;нуж­ный рай­он, в&nbsp;рай­оне их отправ­ля­ют в&nbsp;дом, подъ­езд и, нако­нец, квар­ти­ру.</p>
						<p>Паке­ты при­хо­дят в&nbsp;вашу коро­боч­ку у&nbsp;две­ри. Она нахо­дит, какой ком­пью­тер запра­ши­вал дан­ные из «Яндек­са», и&nbsp;отправ­ля­ет ему по&nbsp;бес­про­вод­ной свя­зи толь­ко что при­шед­шие паке­ты.</p>
						<p>Ваш ком­пью­тер полу­ча­ет паке­ты, рас­па­ко­вы­ва­ет их, соби­ра­ет цель­ный текст и&nbsp;рису­ет из это­го тек­ста стра­ни­цу.</p>
						<p>На&nbsp;весь путь из&nbsp;вашей квар­ти­ры до&nbsp;сер­ве­ра «Яндек­са» и&nbsp;обрат­но ушло мень­ше секун­ды, но&nbsp;в&nbsp;про­цес­се было задей­ство­ва­но не&nbsp;менее пяти­де­ся­ти машин&nbsp;— роу­те­ров и&nbsp;сер­ве­ров. Ваш запрос физи­че­ски про­пу­те­ше­ство­вал до&nbsp;сер­ве­ра «Яндек­са» и&nbsp;вер­нул­ся. У&nbsp;вас ощу­ще­ние, буд­то вы&nbsp;зашли в «Яндекс», но&nbsp;на&nbsp;самом деле «Яндекс» при­шёл в&nbsp;ваш дом.</p>
						<p>Это толь­ко самые осно­вы. Даль­ше раз­бе­рём, что мож­но с&nbsp;эти­ми зна­ни­я­ми делать, как рабо­та­ют бло­ки­ров­ки интер­не­та и&nbsp;поче­му они на&nbsp;самом деле не&nbsp;рабо­та­ют, а&nbsp;глав­ное&nbsp;— как сде­лать соб­ствен­ный сайт, кото­рый будет рабо­тать не&nbsp;хуже «Яндек­са».</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basics">
					<div class="roadmap__content-item-title">Как работает браузер</div>
					<div class="roadmap__content-text">
						<h3>Интернет — это много компьютеров</h3>
						<p> Интернет — это много вычислительных машин, которые объединены в сеть. Объединение в сеть означает, что одна вычислительная машина может отправить другой сообщение, а та может ответить. </p>
						<p> клиент делает запрос серверу, тот даёт ответ, и на клиенте выводится ответ </p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHttpCodes">
					<div class="roadmap__content-item-title">HTTP Status codes</div>
					<div class="roadmap__content-text">
						<ol>
							<li>Servers send HTTP status codes to provide quick information on the response sent by the client.</li>
							<li>HTTP status codes have consequences on caching, and handling of URIs on the client side.</li>
							<li>There are different families of HTTP status codes.</li>
						</ol>
						<h4>HTTP codes</h4>
						<ol>
							<li>1xx (Informational): Request received, continuing process.</li>
							<li>2xx (Successful): The action was successfully received, understood, and accepted.</li>
							<li>3xx (Redirection): Further action needs to be taken in order to complete the request.</li>
							<li>4xx (Client Error): The request contains bad syntax or cannot be fulfilled.</li>
							<li>5xx (Server Error): The server failed to fulfil an apparently valid request.</li>
						</ol>
						<table class="standard-table" style="width: 100%;">
							<thead>
								<tr>
									<th scope="col">Код ответа</th>
									<th scope="col">Название</th>
									<th scope="col">Описание</th>
									<th scope="col">Версия HTTP</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<th colspan="4"><em>Информационные</em></th>
								</tr>
								<tr>
									<td id="100">100</td>
									<td>Continue</td>
									<td>"Продолжить". Этот промежуточный ответ указывает, что запрос успешно принят и клиент может продолжать присылать запросы либо проигнорировать этот ответ, если запрос был завершён.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<td id="101">101</td>
									<td>Switching Protocol</td>
									<td>"Переключение протокола". Этот код присылается в ответ на запрос клиента, содержащий заголовок <code>Upgrade:</code>, и указывает, что сервер переключился на протокол, который был указан в заголовке. Эта возможность позволяет перейти на несовместимую версию протокола и обычно не используется.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<td>102</td>
									<td>Processing</td>
									<td>"В обработке". Этот код указывает, что сервер получил запрос и обрабатывает его, но обработка еще не завершена.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<td>103</td>
									<td>Early Hints</td>
									<td>"Ранние подсказки". В ответе сообщаются ресурсы, которые могут быть загружены заранее, пока сервер будет подготовливать основной ответ.&nbsp;<a class="external" href="https://datatracker.ietf.org/doc/rfc8297" rel="noopener">RFC 8297 (Experimental)</a>.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<th colspan="4"><em>Успешные</em></th>
								</tr>
								<tr>
									<td id="200">200</td>
									<td>
										<p>OK</p>
									</td>
									<td>"Успешно". Запрос успешно обработан. Что значит "успешно", зависит от метода HTTP, который был запрошен: <ul>
											<li>GET: "ПОЛУЧИТЬ". Запрошенный ресурс был найден и передан в теле ответа.</li>
											<li>HEAD: "ЗАГОЛОВОК". Заголовки переданы в ответе.</li>
											<li>POST: "ПОСЫЛКА". Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.</li>
											<li>TRACE: "ОТСЛЕЖИВАТЬ". Тело ответа содержит тело запроса полученного сервером.</li>
										</ul>
									</td>
									<td>HTTP/0.9 и выше</td>
								</tr>
								<tr>
									<td id="201">201</td>
									<td>Created</td>
									<td>"Создано". Запрос успешно выполнен и в результате был создан ресурс. Этот код обычно присылается в ответ на запрос PUT "ПОМЕСТИТЬ".</td>
									<td>HTTP/0.9 и выше</td>
								</tr>
								<tr>
									<td id="202">202</td>
									<td>Accepted</td>
									<td>"Принято". Запрос принят, но ещё не обработан. Не поддерживаемо, т.е., нет способа с помощью HTTP отправить асинхронный ответ позже, который будет показывать итог обработки запроса. Это предназначено для случаев, когда запрос обрабатывается другим процессом или сервером, либо для пакетной обработки.</td>
									<td>HTTP/0.9 и выше</td>
								</tr>
								<tr>
									<td id="203">203</td>
									<td>Non-Authoritative Information</td>
									<td>"Информация не авторитетна". Этот код ответа означает, что информация, которая возвращена, была предоставлена не от исходного сервера, а из какого-нибудь другого источника. Во всех остальных ситуациях более предпочтителен код ответа 200 OK.</td>
									<td>HTTP/0.9 и 1.1</td>
								</tr>
								<tr>
									<td id="204">204</td>
									<td>No Content</td>
									<td>"Нет содержимого". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.</td>
									<td>HTTP/0.9 и выше</td>
								</tr>
								<tr>
									<td id="205">205</td>
									<td>Reset Content</td>
									<td>"Сбросить содержимое". Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<td id="206">206</td>
									<td>Partial Content</td>
									<td>"Частичное содержимое". <span id="result_box" lang="ru"><span class="hps">Этот код ответа</span> <span class="hps">используется, когда клиент присылает&nbsp;</span><span class="hps">заголовок</span> <span class="hps">диапазона</span><span>, чтобы</span> выполнить <span class="hps">загрузку отдельно,</span> <span class="hps">в</span> <span class="hps">несколько потоков</span></span>.</td>
									<td>Только HTTP/1.1</td>
								</tr>
								<tr>
									<th colspan="4"><em>Сообщения о перенаправлениях</em></th>
								</tr>
								<tr>
									<td id="300">300</td>
									<td>Multiple Choice</td>
									<td>
										<p><span id="result_box" lang="ru"><span>"</span></span><span class="short_text" id="result_box" lang="ru"><span class="alt-edited">Множественный выбор</span></span>"<span lang="ru"><span>. </span></span>Этот код ответа присылается, когда з<span lang="ru"><span>апрос</span> <span>имеет более чем</span> <span>один из возможных</span> <span>ответов</span><span>.</span> И <span>User-agent </span><span>или</span> <span>пользователь должен</span> <span>выбрать один из ответов</span><span>. </span></span>Не существует стандартизированного способа выбора&nbsp;одного&nbsp;из полученных ответов.</p>
									</td>
									<td>HTTP/1.0 and later</td>
								</tr>
								<tr>
									<td id="301">301</td>
									<td>Moved Permanently</td>
									<td>
										<p>"Перемещён на постоянной основе". Этот код ответа значит, что <span id="result_box" lang="ru"><span>URI </span><span>запрашиваемого</span> <span>ресурса</span> <span>был изменен</span><span>.</span> <span>Возможно,</span> <span>новый</span> <span>URI </span></span><span lang="ru"><span>будет </span></span>предоставлен <span lang="ru"><span>в ответе.</span></span></p>
									</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="302">302</td>
									<td>Found</td>
									<td>
										<p>"Найдено". Этот код ответа значит, что запрошенный ресурс <em>временно изменен</em>. <span id="result_box" lang="ru"><span>Новые</span> <span>изменения в</span> <span>URI</span> <span>могут быть</span></span> доступны в <span id="result_box" lang="ru"><span>будущем</span></span>. <span id="result_box" lang="ru"><span>Таким образом,</span> этот<span> </span><span>URI,</span> <span>должен</span> <span>быть использован</span> <span>клиентом</span> <span>в</span> <span>будущих запросах</span><span>.</span></span></p>
									</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="303">303</td>
									<td>See Other</td>
									<td>"Просмотр других ресурсов". Этот код ответа присылается,&nbsp;чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.</td>
									<td>HTTP/0.9 and 1.1</td>
								</tr>
								<tr>
									<td id="304">304</td>
									<td>Not Modified</td>
									<td>"Не модифицировано". Используется для кэширования. Это код ответа значит, что запрошенный ресурс не был изменен. Таким образом, клиент может продолжать использовать кэшированную версию ответа.</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="305">305</td>
									<td>Use Proxy</td>
									<td>"Использовать прокси". Это означает, что запрошенный ресурс должен быть доступен через прокси. Этот код ответа в основном не поддерживается из соображений безопасности.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="306">306</td>
									<td>Switch Proxy</td>
									<td>Больше не использовать. Изначально подразумевалось, что " последующие запросы должны использовать указанный прокси."</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="307">307</td>
									<td>Temporary Redirect</td>
									<td>"Временное перенаправление".&nbsp;Сервер отправил этот ответ, чтобы клиент получил запрошенный ресурс на другой URL-адрес с тем же методом, который использовал предыдущий запрос. Данный код имеет ту же семантику, что код ответа&nbsp;<code>302 Found</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если в первом запросе использовался <code>POST</code>, то во втором запросе также должен использоваться <code>POST</code>.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="308">308</td>
									<td>Permanent Redirect</td>
									<td>
										<p>"Перенаправление на постоянной основе". Это означает, что ресурс теперь постоянно находится в другом URI, указанном в заголовке <code>Location:</code> HTTP Response. Данный код ответа имеет ту же семантику, что и код ответа&nbsp;<code>301 Moved Permanently</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если <code>POST</code> использовался в первом запросе, <code>POST</code> должен использоваться и во втором запросе.</p>
										<div class="note"><strong>Примечание:</strong>&nbsp;Это экспериментальный код ответа, Спецификация которого в настоящее время находится в черновом виде.</div>
									</td>
									<td><a class="external" href="http://greenbytes.de/tech/webdav/draft-reschke-http-status-308-07.html" rel="noopener" title="http://greenbytes.de/tech/webdav/draft-reschke-http-status-308-07.html">draft-reschke-http-status-308</a></td>
								</tr>
								<tr>
									<th colspan="4"><em>Клиентские</em></th>
								</tr>
								<tr>
									<td id="400">400</td>
									<td>Bad Request</td>
									<td>"Плохой запрос". Этот ответ означает, что сервер не понимает запрос из-за неверного синтаксиса.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="401">401</td>
									<td>Unauthorized</td>
									<td>"Неавторизовано". Для получения запрашиваемого ответа нужна аутентификация. Статус похож на статус 403, но,в этом случае, аутентификация возможна.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="402">402</td>
									<td>Payment Required</td>
									<td>"Необходима оплата". Этот код ответа зарезервирован для будущего использования. Первоначальная цель для создания этого когда была в использовании его для цифровых платежных систем(на данный момент не используется).</td>
									<td>HTTP/0.9 and 1.1</td>
								</tr>
								<tr>
									<td id="403">403</td>
									<td>Forbidden</td>
									<td>"Запрещено". У клиента нет прав доступа к содержимому, поэтому сервер отказывается дать надлежащий ответ.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="404">404</td>
									<td>Not Found</td>
									<td>"Не найден". Сервер не может найти запрашиваемый ресурс. Код этого ответа, наверно, самый известный из-за частоты его появления в вебе.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="405">405</td>
									<td>Method Not Allowed</td>
									<td>"Метод не разрешен". Сервер знает о запрашиваемом методе, но он был деактивирован и не может быть использован. Два обязательных метода,&nbsp;&nbsp;<code>GET</code> и&nbsp;<code>HEAD</code>,&nbsp; никогда не должны быть деактивированы и не должны возвращать этот код ошибки.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="406">406</td>
									<td>Not Acceptable</td>
									<td>
										<p>Этот ответ отсылается, когда веб сервер после выполнения&nbsp;<a href="/en/HTTP/Content_negotiation#Server-driven_negotiation" title="https://developer.mozilla.org/en/HTTP/Content_negotiation#Server-driven_negotiation">server-driven content negotiation</a>, не нашел контента, отвечающего критериям, полученным из user agent.</p>
									</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="407">407</td>
									<td>Proxy Authentication Required</td>
									<td>Этот код ответа аналогичен коду 401, только аутентификация требуется для прокси сервера.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="408">408</td>
									<td>Request Timeout</td>
									<td>Ответ с таким кодом может прийти, даже без предшествующего запроса. Он означает, что сервер хотел бы отключить это неиспользуемое соеднинение. Этот метод используется все чаще с тех пор, как некоторые браузеры, вроде Chrome и IE9, стали использовать <a class="external" href="http://www.belshe.com/2011/02/10/the-era-of-browser-preconnect/" rel="noopener" title="http://www.belshe.com/2011/02/10/the-era-of-browser-preconnect/">HTTP механизмы предварительного соединения</a>&nbsp;для ускорения серфинга&nbsp; (смотрите <a class="external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=881804" rel="noopener">баг&nbsp;881804</a>, будущей реализации этого механизма в Firefox).&nbsp;Также учитывайте, что некоторые серверы прерывают соединения не отправляя подобных сообщений.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="409">409</td>
									<td>Conflict</td>
									<td>
										<p>Этот ответ отсылается, когда запрос конфликтует с текущим состоянием сервера.</p>
									</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="410">410</td>
									<td>Gone</td>
									<td>
										<p>Этот ответ отсылается, когда запрашиваемый контент удален с сервера.</p>
									</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="411">411</td>
									<td>Length Required</td>
									<td>
										<p>Запрос отклонен, потому что сервер требует указание заголовка&nbsp;<code>Content-Length</code>, но он не указан.</p>
									</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="412">412</td>
									<td>Precondition Failed</td>
									<td>Клиент указал в своих заголовках условия, которые сервер не может выполнить</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="413">413</td>
									<td>Request Entity&nbsp;Too Large</td>
									<td>
										<p>Размер запроса превышает лимит, объявленный сервером. Сервер может закрыть соединение, вернув&nbsp;заголовок <code>Retry-After</code></p>
									</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="414">414</td>
									<td>Request-URI Too Long</td>
									<td>URI запрашиваемый клиентом слишком длинный для того, чтобы сервер смог его обработать</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="415">415</td>
									<td>Unsupported Media Type</td>
									<td>Медиа формат запрашиваемых данных не поддерживается сервером, поэтому запрос отклонен</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="416">416</td>
									<td>Requested Range Not Satisfiable</td>
									<td>Диапозон указанный заголовком запроса&nbsp;<code>Range</code> не может быть выполнен; возможно, он выходит за пределы переданного URI</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="417">417</td>
									<td>Expectation Failed</td>
									<td>Этот код ответа означает, что ожидание, полученное из заголовка запроса&nbsp;<code>Expect</code>, не может быть выполнено сервером.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<th colspan="4"><em>Серверные</em></th>
								</tr>
								<tr>
									<td id="500">500</td>
									<td>Internal Server Error</td>
									<td>"Внутренняя ошибка сервера". Сервер столкнулся с ситуацией, которую он не знает как обработать.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="501">501</td>
									<td>Not Implemented</td>
									<td>"Не выполнено". Метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые сервера должны поддерживать (и, соответственно, не должны возвращать этот код) -&nbsp;&nbsp;<code>GET</code>&nbsp;и&nbsp;<code>HEAD</code>.</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="502">502</td>
									<td>Bad Gateway</td>
									<td>"Плохой шлюз". Эта ошибка означает что сервер, во время работы в качестве шлюза для получения ответа, нужного для обработки запроса, получил недействительный (недопустимый) ответ.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="503">503</td>
									<td>Service Unavailable</td>
									<td>"Сервис недоступен". Сервер не готов обрабатывать запрос. Зачастую причинами являются отключение сервера или то, что он перегружен. Обратите внимание, что вместе с этим ответом удобная для пользователей(user-friendly) страница должна отправлять объяснение проблемы.&nbsp; Этот ответ должен использоваться для временных условий и&nbsp;<code>Retry-After:</code> HTTP-заголовок должен, если возможно, содержать&nbsp; предполагаемое время до восстановления сервиса. Веб-мастер также должен позаботиться о заголовках, связанных с кэшем, которые отправляются вместе с этим ответом, так как эти ответы, связанные с временными условиями, обычно не должны кэшироваться.&nbsp;</td>
									<td>HTTP/0.9 and later</td>
								</tr>
								<tr>
									<td id="504">504</td>
									<td>Gateway Timeout</td>
									<td>Этот ответ об ошибке предоставляется, когда сервер действует как шлюз и не может получить ответ вовремя.</td>
									<td>HTTP/1.1 only</td>
								</tr>
								<tr>
									<td id="505">505</td>
									<td>HTTP Version Not Supported</td>
									<td>"HTTP-версия не поддерживается". HTTP-версия, используемая в запроcе, не поддерживается сервером.</td>
									<td>HTTP/1.1 only</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHowInternetWorks">
					<div class="roadmap__content-item-title">Semantic HTML</div>
					<div class="roadmap__content-text"> asd </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsCookies">
					<div class="roadmap__content-item-title">Cookies</div>
					<div class="roadmap__content-text">
						<h3>Что такое куки?</h3>
						<p>Куки — это малень­кий файл с дан­ны­ми, кото­рый хра­нит­ся у вас на ком­пью­те­ре. Обыч­но в нём хра­нят дан­ные о том, был ли уже поль­зо­ва­тель на этом сай­те, и если да — то под каким име­нем и что там делал.</p>
						<p>Куки не могут выполниться сами по себе, что-то сделать или удалить важный файл. Это просто текст, который лежит на компьютере. Когда у куки заканчивается срок годности, браузер её удаляет, но есть бессрочные куки: они сами не удаляются, но и не вредят при этом компьютеру. Единственное, что делает куки — <b>хранит нужную информацию для сайта.</b></p>
						<h5>на практике обычно используется для</h5>
						<ol>
							<li>аутентификации пользователя;</li>
							<li>хранения персональных предпочтений и настроек пользователя;</li>
							<li>отслеживания состояния сеанса доступа пользователя;</li>
							<li>сведения статистики о пользователях.</li>
						</ol>
						<p>Cookie легко перехватить и подменить (например, для получения доступа к учётной записи), если пользователь использует нешифрованное соединение с сервером. В группе риска пользователи, выходящие в интернет при помощи публичных точек доступа Wi-Fi и не использующие при этом таких механизмов, как SSL и TLS. Шифрование позволяет также решить и другие проблемы, связанные с безопасностью передаваемых данных.</p>
						<h4>Понятие</h4>
						<p>В техническом плане cookie представляют собой фрагменты данных, изначально отправляемых веб-сервером браузеру. При каждом последующем посещении сайта браузер пересылает их обратно серверу. Без cookie каждый просмотр веб-страницы является изолированным действием, не связанным с просмотром других страниц того же сайта, с помощью же cookie можно выявить связь между просмотром разных страниц. </p>
						<p>Спецификации указывают минимальные объёмы, которые должны предоставляться браузерами для хранения cookie. Так, браузер должен хранить по меньшей мере 300 cookie по 4096 байт каждая, и по меньшей мере 20 cookie для одного сервера или домена.</p>
						<p><b>Имена cookie нечувствительны к регистру</b></p>
						<p>Cookie могут устанавливать дату их удаления, в этом случае они будут автоматически удалены браузером в указанный срок. Если дата удаления не указана, cookie удаляются сразу, как только пользователь закроет браузер. Таким образом, указание даты истечения позволяет сохранить cookie более чем на один сеанс и такие cookie называются постоянными. Например, интернет-магазин может использовать постоянные cookie для хранения кодов предметов, которые пользователь поместил в корзину покупок — и даже если пользователь закроет браузер, не совершив покупки, при последующем входе ему не придётся формировать корзину заново.</p>
						<p>Хранение cookie также может ограничиваться в зависимости от веб-сервера, домена или поддомена, где они были созданы.</p>
						<h4>Типы cookie</h4>
						<ol>
							<li><b>Сессионные</b> - также известные как временные cookie, существуют только во временной памяти, пока пользователь находится на странице веб-сайта. Браузеры обычно удаляют сессионные cookie после того, как пользователь закрывает окно браузера. В отличие от других типов cookie, сессионные cookie не имеют истечения срока действия, и поэтому браузеры понимают их как сессионные.</li>
							<li><b>Постоянные</b> - Вместо того, чтобы удаляться после закрытия браузера, как это делают сессионные cookie, постоянные cookie-файлы удаляются в определённую дату или через определённый промежуток времени. Это означает, что информация о cookie будет передаваться на сервер каждый раз, когда пользователь посещает веб-сайт, которому эти cookie принадлежат. По этой причине постоянные cookie иногда называются следящие cookie, поскольку они могут использоваться рекламодателями для записи о предпочтениях пользователя в течение длительного периода времени. Однако, они также могут использоваться и в «мирных» целях, например, чтобы избежать повторного ввода данных при каждом посещении сайта.</li>
							<li><b>Сторонние</b> - Обычно атрибут домена cookie совпадает с доменом, который отображается в адресной строке веб-браузера. Это называется первый файл cookie. Однако сторонний файл cookie принадлежит домену, отличному от того, который указан в адресной строке. Этот тип файлов cookie обычно появляется, когда веб-страницы содержат контент с внешних веб-сайтов, например рекламные баннеры. Это открывает возможности для отслеживания истории посещений пользователя и часто используется рекламодателями для предоставления релевантной рекламы каждому пользователю.</li>
							<li>
								<b>Супер</b> - это cookie-файл с источником домена верхнего уровня (например, .ru) или общедоступным суффиксом (например, .co.uk). Обычные cookie, напротив, имеют происхождение от конкретного доменного имени, например example.com. <br />
								<p>Супер-cookie могут быть потенциальной проблемой безопасности и поэтому часто блокируются веб-браузерами. Если браузер разблокирует вредоносный веб-сайт, злоумышленник может установить супер-cookie и потенциально нарушить или выдать себя за законные запросы пользователей на другой веб-сайт, который использует тот же домен верхнего уровня или общедоступный суффикс, что и вредоносный веб-сайт. Например, супер-cookie с происхождением .com может злонамеренно повлиять на запрос к example.com, даже если файл cookie не был создан с сайта example.com. Это может быть использовано для подделки логинов или изменения информации пользователя.</p>
							</li>
							<li><b>Зомби</b> - Поскольку cookie можно очень легко удалить из браузера, программисты ищут способы идентифицировать пользователей даже после полной очистки истории браузера. Одним из таких решений являются зомби-cookie (или evercookie, или persistent cookie) — не удаляемые или трудно удаляемые cookie, которые можно восстановить в браузере с помощью JavaScript. Это возможно потому, что для хранения куков сайт одновременно использует все доступные хранилища браузера (HTTP ETag, Session Storage, Local Storage, Indexed DB), в том числе и хранилища приложений, таких как Flash Player (Local Shared Objects), Microsoft Silverlight (Isolated Storage) и Java (Java persistence API). Когда программа обнаруживает отсутствие в браузере cookie-файла, информация о котором присутствует в других хранилищах — она тут же восстанавливает его на место и, тем самым, идентифицирует пользователя для сайта.</li>
						</ol>
						<h4>Параметры cookie</h4>
						<p><a href="https://tools.ietf.org/html/rfc6265" title="">RFC 6265</a> дает конкретные указания, как нужно интерпретировать каждый из параметров cookie:</p>
						<p><code>name</code> устанавливает имя cookie-файла.</p>
						<p><code>value</code> сохраняет значение cookie, которое будет идентифицировать пользователя или содержать служебную информацию.</p>
						<p><code>expires</code> и <code>max-age</code> определяют срок жизни cookie, по истечению которого она будет автоматически удалена. Если не указать этот параметр, или установить его значение в ноль, то cookie будут автоматически удалены при закрытии браузера. Для параметра <code>expires</code> указывается конечная дата в формате <i>Tue, 01-Sep-2020 10:50:22 GMT,</i> тогда как для <code>max-age</code> устанавливается количество секунд жизни cookie с момента установки её в браузер.</p>
						<p><code>path</code> указывает путь к директории на сервере, для которой будут доступны cookie. Если указать корневой каталог <code>/</code>, то cookie будут доступны всему домену. По умолчанию значением является текущая директория, из которой cookie устанавливаются в браузер.</p>
						<p><code>domain</code> отмечает, какой домен или поддомен имеет доступ к этой cookie. Для того, чтобы сделать cookie доступными для всего домена (включая поддомены), нужно просто указать имя домена (например <i>example.com</i>).</p>
						<p><code>secure</code> параметр указывает браузеру, что cookie должны передаваться на сервер только по защищенному https-соединению.</p>
						<p><code>httponly</code> параметр запрещает доступ к cookie посредством API <code>document.cookie</code>. Эта возможность была предложена в качестве меры для эффективного предотвращения краж cookie посредством XSS-атак.</p>
						<p><code>samesite</code> это относительно новый параметр (определенный в <a rel="nofollow" class="external text" href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00">RFC 6265bis</a>), который сообщает браузерам, что cookie не должны отсылаться с межсайтовыми запросами. Это в некотором роде обеспечивает защиту от межсайтовых подделок запроса (CSRF). У этого параметра есть три состояния, которые определяют поведение cookie для различных сценариев пользования сайтом.</p>
						<p><code>samesite=none</code> прямо указывает, что на передачу cookie-файлов не накладывается никаких ограничений.</p>
						<p><code>samesite=lax</code> разрешает передачу cookie только безопасными HTTP-методами, которыми, согласно RFC 7231, являются GET, HEAD, OPTIONS и TRACE.</p>
						<p><code>samesite=strict</code> или просто <code>samesite</code> является самым строгим вариантом безопасности и блокирует отправку cookie с любыми запросами от других ресурсов. Cookie будут передаваться только в пределах того домена, с которого они и были установлены.</p>
						<h4>Доступ из JavaScript посредством <code>Document.cookie</code></h4>
						<pre class="language-javascript">
	<code>
		document.cookie = "yummy_cookie=choco";
		document.cookie = "tasty_cookie=strawberry";
		console.log(document.cookie);
		// logs "yummy_cookie=choco; tasty_cookie=strawberry"
	</code>
</pre>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsWebStorage">
					<div class="roadmap__content-item-title">Web Storage</div>
					<div class="roadmap__content-text">
						<h3>Основы Веб хранилища и его использование</h3>
						<h5>В основе Веб хранилища лежат два механизма:</h5>
						<ol>
							<li><code>хранилище сессии (sessionStorage)</code> обслуживает область хранения данных для каждого домена, доступное на протяжении сессии. (пока браузер открыт, даже в случае перезагрузки страницы) </li>
							<li><code>локальное хранилище (localStorage)</code> делает то же самое, но сохраняет данные даже в случае, если переоткрыть браузер. </li>
						</ol>
						<p>Обе функции доступны через <a href="https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage" title="Свойство sessionStorage позволяет получить доступ к объекту Storage текущей сессии. Свойство sessionStorage очень похоже на свойство Window.localStorage, единственное различие заключается в том, что все данные, сохраненные в localStorage не имеют определенного времени жизни, а данные в sessionStorage очищаются в момент окончания сессии текущий страницы. Сессия страницы остается активной все время пока окно браузера открыто и сохраняется между перезагрузками страниц. Открытие той же страницы в новом окне браузера или новой вкладке приводит к созданию новой сессии страницы, что отличается от поведения session cookies."><code>Window.sessionStorage</code></a> и <a href="https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage" title="Свойство localStorage позволяет получить доступ к локальному Storage объекту. localStorage аналогично свойству sessionStorage. Разница только в том, что свойство sessionStorage хранит данные в течение сеанса (до закрытия браузера), в отличие от данных,  находящихся в свойстве localStorage, которые не имеют ограничений по времени хранения и могут быть удалены только с помощью JavaScript."><code>Window.localStorage</code></a> свойства (если быть более точным, в браузерах, поддерживающих хранилища объект <code>Window</code> выполняет объекты <code>WindowLocalStorage</code> и <code>WindowSessionStorage</code>, которые содержат свойства <code>localStorage</code> и <code>sessionStorage</code>) — вызов одного из них создает представление объекта <a href="/ru/docs/Web/API/Storage" title="Интерфейс Storage из Web Storage API предоставляет доступ для session storage или local storage для конкретного домена, позволяя вам к примеру добавлять, изменять или удалять сохранённые элементы данных."><code>Storage</code></a>, через который можно устанавливать, редактировать и удалять данные. Для каждого из типа хранилищ и по каждому домену используется отдельное представление Storage объекта - они функционируют и управляются отдельно друг от друга. </p> тут пробельчик дальше википелия <p>Интернет-хранилище или DOM-хранилище — это программные методы и протоколы веб-приложения, используемые для хранения данных в веб-браузере. Интернет-хранилище представляет собой постоянное хранилище данных, похожее на куки, но со значительно расширенной ёмкостью и без хранения информации в заголовке запроса HTTP. Существуют два основных типа веб-хранилища: локальное хранилище (localStorage) и сессионное хранилище (sessionStorage), ведущие себя аналогично постоянным и сессионным кукам соответственно.</p>
						<p>В настоящее время стандарты Интернет-хранилища разработаны и предложены <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D0%BE%D1%80%D1%86%D0%B8%D1%83%D0%BC_%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%BE%D0%B9_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D1%8B" title="Консо́рциум Всеми́рной паути́ны — организация, разрабатывающая и внедряющая технологические стандарты для Всемирной паутины.">WWW Консорциумом (W3C)</a>. Первоначально стандарты были частью спецификации HTML 5, но сейчас являются отдельной спецификацией. Интернет-хранилище поддерживается Internet Explorer 8 и выше, Mozilla-браузерами (например, Firefox 2+, официально от 3,5), Safari 4 и выше, Google Chrome 4 (поддержка sessionStorage добавлена от 5) и Opera начиная с версии 10.50<sup id="cite_ref-3" class="reference"></sup>. </p>
						<h4>Размер хранилища</h4>
						<p>Интернет-хранилище поддерживает 5 Мбайт на домен в Mozilla Firefox, Google Chrome, и Opera, и 10 Мбайт в Internet Explorer места на диске в сравнении с куки, которому доступно всего 4 Кбайта</p>
						<h5>Интерфейс на стороне клиента</h5>
						<p>В отличие от куки, которые могут быть доступны как на сервере, так и на стороне клиента, веб-хранилище попадает исключительно под компетенцию сценариев (скриптов) на стороне клиента. Данные интернет-хранилища не передаются на сервер при каждом запросе HTTP, и веб-сервер не может напрямую записать в интернет-хранилище.</p>
						<h5>Локальное хранилище и Сессионное хранилище</h5>
						<p>Интернет-хранилище предлагает две различных области: Локальное хранилище и Сессионное хранилище, которые отличаются по своим масштабам и времени жизни. Данные размещаются в отдельное для каждого домена локальное хранилище (оно доступно для всех скриптов из домена, который первоначально добавил данные) и сохраняются после закрытия браузера. Сессия сохраняется по принципу одна страница-одно окно и ограничивается жизнью данного окна, то есть для каждого открытого окна создаётся новая сессия, которая прекращает своё существование при закрытии окна и не зависит от домена открывшего её. Сохранение сессии предназначено для предоставления отдельных экземпляров одного и того же веб-приложения для работы в разных окнах, не мешая друг другу[5]. В случае с куки подобное становится крайне затруднительно или даже невозможно.</p>
						<h5>Интерфейс и модель данных</h5>
						<p>Интернет-хранилище в настоящее время предоставляет программный интерфейс лучше, чем куки. Интерфейс представляет собой ассоциативный массив модели данных, где ключи и значения являются строками. Дополнительный API для доступа к структурированным данным на основе SQL находится на рассмотрении рабочей группы W3C.</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHowInternetWorks">
					<div class="roadmap__content-item-title">Basic SEO</div>
					<div class="roadmap__content-text"> asd </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="basicsHowInternetWorks">
					<div class="roadmap__content-item-title">Accessibility</div>
					<div class="roadmap__content-text"> asd </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="js">
					<div class="roadmap__content-item-title">JavaScript</div>
					<div class="roadmap__content-text">
						<h4>Data Types</h4>
						<pre class="language-javascript">
	<code>
		"Any text" // 1. String
		123.45 // 2. Number
		true or false // 3. Boolean
		null // 4. Null
		undefined // 5. Undefined
		Symbol('something') // 6. Symbol
		{ key: 'value'} // 7. Object
		[1, "text", false] // - Array
		function name() { } // - Function
	</code>
</pre>
						<h4>Object</h4>
						<p>An object is a data type in JavaScript that is used to store a combination of data in a simple key-value pair.</p>
						<pre class="language-javascript">
	<code>
		var hero = {
		name: "Thor",
		yearOfBirth: '-15621651',
		calculateAge: function(){
		// some code to calculate age
	}
}

</code>
</pre>
						<h4>Function</h4>
						<p>Функция — это мини-программа, которая получает на вход какие-то данные, что-то делает внутри себя и может отдавать какие-то данные в результате вычислений.</p>
						<h3>OOP</h3>
						<h4>Объект</h4>
						<p>Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм</p>
						<ul>
							<li>
								<p><span>инкапсуляция</span> — объект независим</p>
								<p>Нужные для объекта данные живут внутри этого объекта, а не где-то снаружи в программе (например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку»). Также означает скрытие внутренней реализации от других компонентов. Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения (<a target="blank" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title='Метод чтения, геттер (getter — получатель) — специальный метод, позволяющий получить данные, доступ к которым напрямую ограничен.'>геттер</a>) и изменения (<a target="blank" href="" title='Устанавливающий метод, сеттер (англ. setter) или модифицирующий метод, мутатор (англ. mutator) — метод, используемый в объектно-ориентированном программировании для того, чтобы присвоить какое-либо значение инкапсулированному полю, например, обработав при этом недопустимые присваивания.'>сеттер</a>) её значения.</p>
							</li>
							<li>
								<p><span>абстракция</span> — у объекта есть «<a target="blank" href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)' title="Интерфе́йс (англ. interface) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).">интерфейс</a>»</p>
								<p>Aбстракция нужна что бы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи</p>
								<p>у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс. В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения. Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/7-1.jpg" alt="" />
							</li>
							<li>
								<p><span>наследование</span> — единый язык общения</p>
								<p>ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать. Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить». На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у идеального покупателя, плюс могут быть какие-то свои, если захотите. Идеальные объекты программисты называют классами.</p>
							</li>
							<li>
								<p><span>полиморфизм</span> — способность к копированию</p>
								<p>В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть». При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/8-1.jpg" alt="" />
								<p>Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если правила работы с ним остались прежними.</p>
							</li>
						</ul>
						<p>Плюсы и минусы ООП У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов. Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объект и из чего он состоит. Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием. Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок. Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип. А теперь про минусы: Сложно понять и начать работать. Подход ООП намного сложнее обычного процедурного программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода. Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная. Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем процедурная (хотя с современными мощностями процессоров это мало кого волнует).</p>
						<p>Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании</p>
						<p>данные внутри объекта называются свойствами, а функции — методами</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsEnginesV8">
					<div class="roadmap__content-item-title">EnginesV8</div>
					<div class="roadmap__content-text">
						<iframe src="https://alligator.io/js/v8-engine/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsJSON">
					<div class="roadmap__content-item-title">JSON</div>
					<div class="roadmap__content-text">
						<p>The <code>JSON</code> object, available in all modern browsers, has two very useful methods to deal with JSON-formatted content: <code>parse</code> and <code>stringify</code>. <strong>JSON.parse()</strong> takes a JSON string and transforms it into a JavaScript object. <strong>JSON.stringify()</strong> takes a JavaScript object and transforms it into a JSON string.</p>
						<pre class="">
	<code class="language-javascript line-numbers">
		const myObj = {
		  name: 'Skip',
		  age: 2,
		  favoriteFood: 'Steak'
		};

		const myObjStr = JSON.stringify(myObj);

		console.log(myObjStr);
		// "{"name":"Skip","age":2,"favoriteFood":"Steak"}"

		console.log(JSON.parse(myObjStr));
		// Object {name:"Skip",age:2,favoriteFood:"Steak"}
	</code>
</pre>
						<p>And although the methods are usually used on objects, they can also be used on arrays:</p>
						<pre class="">
	<code class="language-javascript line-numbers">
		const myArr = ['bacon', 'letuce', 'tomatoes'];

		const myArrStr = JSON.stringify(myArr);

		console.log(myArrStr);
		// "["bacon","letuce","tomatoes"]"

		console.log(JSON.parse(myArrStr));
		// ["bacon","letuce","tomatoes"]
	</code>
</pre>
						<h5>JSON.parse()</h5>
						<p><strong>JSON.parse()</strong> can take an second argument for a <code>reviver</code> function that can transform the object values before they are returned. Here the object’s values are uppercased in the returned object of the <strong>parse</strong> method:</p>
						<pre class="">
	<code class="language-javascript line-numbers">
		const user = {
		  name: 'John',
		  email: 'john@awesome.com',
		  plan: 'Pro'
		};

		const userStr = JSON.stringify(user);

		JSON.parse(userStr, (key, value) => {
		  if (typeof value === 'string') {
		    return value.toUpperCase();
		  }
		  return value;
		});
	</code>
</pre>
						<p><b>Trailing commas are not valid in JSON, so JSON.parse() throws if the string passed to it has trailing commas.</b></p>
						<h5>JSON.stringify()</h5>
						<p><strong>JSON.stringify()</strong> can take two additional arguments, the first one being a <code>replacer</code> function and the second a String or Number value to use as a <code>space</code> in the returned string.</p>
						<p>The replacer function can be used to filter-out values because any value returned as undefined will be out of the returned string:</p>
						<pre class="">
	<code class="language-javascript line-numbers">
		const user = {
		  id: 229,
		  name: 'John',
		  email: 'john@awesome.com'
		};

		function replacer(key, value) {
		  console.log(typeof value);
		  if (key === 'email') {
		    return undefined;
		  }
		  return value;
		}

		const userStr = JSON.stringify(user, replacer);
		// "{"id":229,"name":"John"}"
	</code>
</pre>
						<p>And an example with a <b>space</b> argument passed-in:</p>
						<pre class="">
	<code class="language-javascript line-numbers">
		const user = {
		  name: 'John',
		  email: 'john@awesome.com',
		  plan: 'Pro'
		};

		const userStr = JSON.stringify(user, null, '...');
		// "{
		// ..."name": "John",
		// ..."email": "john@awesome.com",
		// ..."plan": "Pro"
		// }"
	</code>
</pre>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsSyntax">
					<div class="roadmap__content-item-title">Syntax</div>
					<div class="roadmap__content-text">
						<h3>Basic Vocabulary</h3>
						<pre class="language-javascript">
	<code>
		var a = 7 + "2";
	</code>
</pre>
						<p> "var a = 7 + "2";": Statement - A group of words, numbers and operators that do a task is a statement. </p>
						<p> "var": Keyword / <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" title='break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield'>reserved word</a> - Any word that is part of the vocabulary of the programming language is called a keyword. </p>
						<p> "a": Variable - A named reference to a value is a variable. </p>
						<p> "=, +": Operator - Operators are reserved-words that perform action on values and variables </p>
						<p> "7 + "2"": Expression - A reference, value or a group of reference(s) and value(s) combined with operator(s), <strong>which result in a single value</strong>. </p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsScroll">
					<div class="roadmap__content-item-title">Scroll</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/speed-up-scroll-events/"></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsStorage">
					<div class="roadmap__content-item-title">Storage</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/introduction-localstorage-sessionstorage/"></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsObjects">
					<div class="roadmap__content-item-title">Objects</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/dealing-with-objects/" /></iframe>
						<iframe title="object-entries-values" src="https://alligator.io/js/object-entries-values/" /></iframe>
						<iframe title="object-entries-values" src="https://alligator.io/js/objects-prototypes-classes/" /></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsArrays">
					<div class="roadmap__content-item-title">Arrays</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/push-pop-shift-unshift-array-methods/" /></iframe>
						<iframe title="dealing-with-objects" src="https://alligator.io/js/filter-array-method/" /></iframe>
						<iframe title="dealing-with-objects" src="https://alligator.io/js/map-array-method/" /></iframe>
						<iframe title="dealing-with-objects" src="https://alligator.io/js/push-array-method/" /></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsRegExp">
					<div class="roadmap__content-item-title">Regular Expressions</div>
					<div class="roadmap__content-text">
						<iframe title="Axios" src="https://alligator.io/js/regular-expressions-for-regular-people/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsDataTypes">
					<div class="roadmap__content-item-title">Data Types</div>
					<div class="roadmap__content-text">
						<iframe title="data-types" src="https://alligator.io/js/js-data-types/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsThis">
					<div class="roadmap__content-item-title">This</div>
					<div class="roadmap__content-text">
						<iframe title="Axios" src="https://alligator.io/js/this-keyword/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsEventLoop">
					<div class="roadmap__content-item-title">Event Loop</div>
					<div class="roadmap__content-text">
						<img src="./img/roadmap/js/eventLoop/head.webp" alt="" class="head" />
						<p>JavaScript is single-threaded: only one task can run at a time.</p>
						<p>The browser gives us some features that the JavaScript engine itself doesn’t provide: a Web API. This includes the DOM API, setTimeout, HTTP requests, and so on. This can help us create some async, non-blocking behavior 🚀</p>
						<p>When we invoke a function, it gets added to something called the call stack. The call stack is part of the JS engine, this isn’t browser specific. It’s a stack, meaning that it’s first in, last out (think of a pile of pancakes). When a function returns a value, it gets popped off the stack 👋</p>
						<pre class="language-javascript">
	<code>
		function greet() {
		  return console.log("Greetings");
		}

		function respond() {
		  return setTimeout(() => {
		    return console.log("QQ");
		  }, 1000);
		}

		greet();
		respond();
	</code>
</pre>
						<img src="./img/roadmap/js/eventLoop/1.gif" />
						<p>The <code>respond</code> function returns a <code>setTimeout</code> function. The <code>setTimeout</code> is provided to us by the Web API: it lets us delay tasks without blocking the main thread. The callback function that we passed to the <code>setTimeout</code> function, the arrow function <code>() => { return 'Hey' }</code> gets added to the Web API. In the meantime, the <code>setTimeout</code> function and the respond function get popped off the stack, they both returned their values! </p>
						<img src="./img/roadmap/js/eventLoop/2.gif" />
						<p>In the Web API, a timer runs for as long as the second argument we passed to it, 1000ms. The callback doesn’t immediately get added to the call stack, instead it’s passed to something called the queue.</p>
						<img src="./img/roadmap/js/eventLoop/3.gif" />
						<p>This can be a confusing part: it doesn't mean that the callback function gets added to the callstack(thus returns a value) after 1000ms! It simply gets added to the queue after 1000ms. But it’s a queue, the function has got to wait for its turn!</p>
						<p>Now this is the part we’ve all been waiting for… Time for the event loop to do its only task: <strong>connecting the queue with the call stack</strong>! If the call stack is <strong>empty</strong>, so if all previously invoked functions have returned their values and have been popped off the stack, the <em>first item</em> in the queue gets added to the call stack. In this case, no other functions were invoked, meaning that the call stack was empty by the time the callback function was the first item in the queue. </p>
						<img src="./img/roadmap/js/eventLoop/4.gif" />
						<p>The callback is added to the call stack, gets invoked, and returns a value, and gets popped off the stack. </p>
						<img src="./img/roadmap/js/eventLoop/5.gif" />
						<h3>Practice</h3>
						<h4>figuring out what gets logged to the console if we run the following:</h4>
						<pre class="language-javascript">
	<code>
		const foo = () => console.log("First");
		const bar = () => setTimeout(() => console.log("Second"), 500);
		const baz = () => console.log("Third");

		bar();
		foo();
		baz();

		// First
		// Third
		// Second (after 500ms)
	</code>
</pre>
						<img src="./img/roadmap/js/eventLoop/6.gif" />
						<ol>
							<li>We invoke <code>bar</code>. <code>bar</code> returns a <code>setTimeout</code> function.</li>
							<li>The callback we passed to <code>setTimeout</code> gets added to the Web API, the <code>setTimeout</code> function and <code>bar</code> get popped off the callstack. </li>
							<li>The timer runs, in the meantime <code>foo</code> gets invoked and logs <code>First</code>. <code>foo</code> returns (undefined),<code>baz</code> gets invoked, and the callback gets added to the queue.</li>
							<li>
								<code>baz</code> logs <code>Third</code>. The event loop sees the callstack is empty after <code>baz</code> returned, after which the callback gets added to the call stack.</li>
							<li>The callback logs <code>Second</code>.</li>
						</ol>
						<h3>More Practice</h3>
						<h3>One</h3>
						<pre class="language-javascript">
	<code>
		for (var i = 0; i < 4; i += 1) {
		  setTimeout(() => console.log(i), 0);
		}

		// 4 times 4
	</code>
</pre>
						<h5>How to fix????????????????</h5>
						<pre class="language-javascript">
	<code>
		for (var i = 0; i < 4; i += 1) {
		  setTimeout(() => console.log(i), 0);
		}

		// 4 times 4
	</code>
</pre>
						<p>or change var to let</p>
						<pre class="language-javascript">
	<code>
		for (let i = 0; i < 4; i += 1) {
		  setTimeout(() => console.log(i), 0);
		}

		// 0
		// 1
		// 2
		// 3
	</code>
</pre>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsHoisting">
					<div class="roadmap__content-item-title">Hoisting</div>
					<div class="roadmap__content-text">
						<img src="./img/roadmap/js/hoisting/head.webp" alt="" class="head" />
						<p>If you’re new to JavaScript, you may have experienced “weird” behavior where some variables are randomly <code>undefined</code>, <code>ReferenceError</code>s get thrown, and so on. Hoisting is often explained as <em>putting variables and functions to the top of the file</em> but nah, that’s not what’s happening, although the behavior might seem like it 😃</p>
						<p>When the JS engine gets our script, the first thing it does is <strong>setting up memory</strong> for the data in our code. No code is executed at this point, it’s simply just preparing everything for execution. The way that function declarations and variables are stored is different. Functions are stored with a <strong>reference to the entire function</strong>.</p>
						<img src="./img/roadmap/js/hoisting/1.gif" />
						<p>With variables, it’s a bit different. ES6 introduced two new keywords to declare variables: <code>let</code> and <code>const</code>. Variables declared with the <code>let</code> or <code>const</code> keyword are stored <em>uninitialized</em>.</p>
						<img src="./img/roadmap/js/hoisting/2.gif" />
						<p>Variables declared with the <code>var</code> keyword are stored with the default value of <code>undefined</code>. </p>
						<img src="./img/roadmap/js/hoisting/3.gif" />
						<p>Now that the creation phase is done, we can actually execute the code. Let's see what happens if we had 3 console.log statements on top of the file, before we declared the function or any of the variables.</p>
						<p>Since functions are stored with a reference to the entire function code, we can invoke them even <em>before</em> the line on which we created them! 🔥</p>
						<img src="./img/roadmap/js/hoisting/4.gif" />
						<p>When we reference a variable declared with the <code>var</code> keyword before their declaration, it’ll simply return its default value that it was stored with: <code>undefined</code>! However, this could sometimes lead to "unexpected" behavior. In most cases this means you’re referencing it unintentionally (you probably don’t want it to actually have the value of <code>undefined</code>) 😬</p>
						<img src="./img/roadmap/js/hoisting/5.gif" />
						<p>In order to prevent being able to accidentally reference an <code>undefined</code> variable, like we could with the <code>var</code> keyword, a <code>ReferenceError</code> gets thrown whenever we try to access <em>uninitialized</em> variables. The "zone" before their actual declaration, is called the <strong>temporal dead zone</strong>: you cannot reference the variables (this includes ES6 classes as well!) before their initialization.</p>
						<img src="./img/roadmap/js/hoisting/6.gif" />
						<p>When the engine passes the line on which we actually declared the variables, the values in memory are overwritten with the values we actually declared them with.</p>
						<p>(Oops I notice now this should be number 7. Will update asap 😬)</p>
						<img src="./img/roadmap/js/hoisting/7.gif" />
						<p>All done! 🎉 Quick recap:</p>
						<ol>
							<li>Functions and variables are stored in memory for an execution context before we execute our code. This is called <em>hoisting</em>. </li>
							<li>Functions are stored with a reference to the entire functions, variables with the <code>var</code> keyword with the value of <code>undefined</code>, and variables with the <code>let</code> and <code>const</code> keyword are stored <em>uninitialized</em>. </li>
						</ol>
						<p>I hope that the term <em>hoisting</em> is a bit less vague now that we've looked at what's happening when we execute our code. As always, don't worry if it still doesn't make a lot of sense yet. You'll get a lot more comfortable with it the more you work with it. Feel free to ask me for help, I'd love to help you! 😃</p>
						<h3>Practice</h3>
						<h4>figuring out what gets logged to the console if we run the following:</h4>
						<pre class="language-javascript">
	<code>
		let hello;
		console.log("hello :", hello);
		hello = "hello!";
		console.log("hello :", hello);

		// undefined
		// hello!
	</code>
</pre>
						<pre class="language-javascript">
	<code>
		var hello;
		console.log("hello :", hello);
		hello = "hello!";
		console.log("hello :", hello);

		// undefined
		// hello!
	</code>
</pre>
						<pre class="language-javascript">
	<code>
		var hello;
		console.log("hello :", hello);
		var hello = "hello!";
		console.log("hello :", hello);

		// undefined
		// hello!
	</code>
</pre>
						<h5>but!</h5>
						<pre class="language-javascript">
	<code>
		let hello;
		console.log("hello :", hello);
		let hello = "hello!";
		console.log("hello :", hello);

		// ERROR: Uncaught SyntaxError: Identifier 'w' has already been declared
	</code>
</pre>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsClosures">
					<div class="roadmap__content-item-title">Closures</div>
					<div class="roadmap__content-text">
						<iframe title="Axios" src="https://alligator.io/js/closures/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsTryCatch">
					<div class="roadmap__content-item-title">Try/Catch</div>
					<div class="roadmap__content-text">
						<iframe title="Axios" src="https://alligator.io/js/error-handling-try-catch/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsPromises">
					<div class="roadmap__content-item-title">Promises</div>
					<div class="roadmap__content-text">
						<img src="./img/roadmap/js/promises/head.webp" alt="" class="head" />
						<h5>Promise Syntax</h5>
						<p>ES6 introduced Promises. In many tutorials, you'll read something like:</p>
						<blockquote>"A promise is a placeholder for a value that can either resolve or reject at some time in the future"</blockquote>
						<p>We can create a promise, using a <code>Promise</code> constructor that receives a callback. Okay cool, let's try it out!</p>
						<img src="./img/roadmap/js/promises/1.gif" />
						<p>A <code>Promise</code> is an object that contains a <strong>status</strong>, (<code>[[PromiseStatus]]</code>) and a <strong>value</strong> (<code>[[PromiseValue]]</code>). In the above example, you can see that the value of <code>[[PromiseStatus]]</code> is <code>"pending"</code>, and the value of the promise is <code>undefined</code>.</p>
						<p>You'll never have to interact with this object, you can't even access the <code>[[PromiseStatus]]</code> and <code>[[PromiseValue]]</code> properties! However, the values of these properties are important when working with promises.</p>
						<p>The value of the <code>PromiseStatus</code>, the <strong>state</strong>, can be one of three values:</p>
						<ol>
							<li>✅ <code>fulfilled</code>: The promise has been <code>resolved</code>. Everything went fine, no errors occurred within the promise 🥳</li>
							<li>❌ <code>rejected</code> : The promise has been <code>rejected</code>. Argh, something went wrong..</li>
							<li>⏳ <code>pending</code>: The promise has neither resolved nor rejected (yet), the promise is still <code>pending</code>. </li>
						</ol>
						<p>Alright this all sounds great, but <em>when</em> is a promise status <code>"pending"</code>, <code>"fulfilled"</code> or <code>"rejected"</code>? And why does that status even matter?</p>
						<p>In the above example, we just passed the simple callback function <code>() =&gt; {}</code> to the <code>Promise</code> constructor. However, this callback function actually receives two arguments. The value of the first argument, often called <code>resolve</code> or <code>res</code>, is the method to be called when the Promise should <strong>resolve</strong>. The value of the second argument, often called <code>reject</code> or <code>rej</code>, is the value method to be called when the Promise should <strong>reject</strong>, something went wrong.</p>
						<img src="./img/roadmap/js/promises/1.png" />
						<p>Let's try and see that gets logged when we invoke either the <code>resolve</code> or <code>reject</code> method! In my example, I called the <code>resolve</code> method <code>res</code>, and the <code>reject</code> method <code>rej</code>.</p>
						<img src="./img/roadmap/js/promises/2.gif" />
						<p>Awesome! We finally know how to get rid of the <code>"pending"</code> status and the <code>undefined</code> value! The <strong>status</strong> of a promise is <code>"fulfilled"</code> if we invoked the <code>resolve</code> method, and the status of the promise is <code>"rejected</code>" if we invoked the <code>rejected</code> method.</p>
						<p>The <strong>value</strong> of a promise, the value of <code>[[PromiseValue]]</code>, is the value that we pass to the either the <code>resolved</code> or <code>rejected</code> method as their argument.</p>
						<p>Okay so, now we know a little bit better how to control that vague <code>Promise</code> object. But what is it used for?</p>
						<p>Luckily, Promises can help us fix this! First, let's rewrite the entire code block, so that each function returns a <code>Promise</code> instead.</p>
						<p>If the image is loaded and everything went fine, let's <strong>resolve</strong> the promise with the loaded image! Else, if there was an error somewhere while loading the file, let's <strong>reject</strong> the promise with the error that occurred.</p>
						<img src="./img/roadmap/js/promises/2.png" />
						<p>Let's see what happens when we run this in the terminal!</p>
						<img src="./img/roadmap/js/promises/3.gif" />
						<p>Cool! A promise got returned with the value of the parsed data, just like we expected.</p>
						<p>But... what now? We don't care about that entire promise object, we only care about the value of the data! Luckily, there are built-in methods to get a promise's value. To a promise, we can attach 3 methods:</p>
						<ol>
							<li>
								<code>.then()</code>: Gets called after a promise <em>resolved</em>. </li>
							<li>
								<code>.catch()</code>: Gets called after a promise <em>rejected</em>. </li>
							<li>
								<code>.finally()</code>: <em>Always</em> gets called, whether the promise resolved or rejected. </li>
						</ol>
						<img src="./img/roadmap/js/promises/3.png" />
						<p>The <code>.then</code> method receives the value passed to the <code>resolve</code> method.</p>
						<img src="./img/roadmap/js/promises/4.gif" />
						<p>The <code>.catch</code> method receives the value passed to the <code>rejected</code> method</p>
						<img src="./img/roadmap/js/promises/5.gif" />
						<p>Finally, we have the value that got resolved by the promise without having that entire promise object! We can now do whatever we want with this value.</p>
						<p>FYI, when you know that a promise will always resolve or always reject, you can write <code>Promise.resolve</code> or <code>Promise.reject</code> , with the value you want to reject or resolve the promise with!</p>
						<img src="./img/roadmap/js/promises/4.png" />
						<p>In the <code>getImage</code> example, we ended up having to nest multiple callbacks in order to run them. Luckily, the <code>.then</code> handlers can help us with that! 🥳</p>
						<p>The result of the <code>.then</code> itself is a promise value. This means that we can chain as many <code>.then</code>s as we want: the result of the previous <code>then</code> callback will be passed as an argument to the next <code>then</code> callback! </p>
						<img src="./img/roadmap/js/promises/5.png" />
						<p>In the case of the <code>getImage</code> example, we can chain multiple <code>then</code> callbacks in order to pass the processed image onto the next function! Instead of ending up with many nested callbacks, we get a clean <code>then</code> chain. </p>
						<img src="./img/roadmap/js/promises/6.png" />
						<p>Perfect! This syntax already looks way better than the nested callbacks.</p>
						<h5>Microtasks and (Macro)tasks</h5>
						<p>Okay so we know a little better how to create a promise and how to extract values out of a promise. Let's add some more code to the script, and run it again:</p>
						<img src="./img/roadmap/js/promises/6.gif" />
						<p>Wait what?! 🤯</p>
						<p>First, <code>Start!</code> got logged. Okay we could've seen that one coming: <code>console.log('Start!')</code> is on the very first line! However, the second value that got logged was <code>End!</code>, and <em>not</em> the value of the resolved promise! Only after <code>End!</code> was logged, the value of the promise got logged. What's going on here?</p>
						<p>We've finally seen the true power of promises! 🚀 Although JavaScript is single-threaded, we can add asynchronous behavior using a <code>Promise</code>!</p>
						<hr>
						<p>But wait, haven't we seen that before? 🤔 In the <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">JavaScript event loop</a>, can't we also use methods native to the browser such as <code>setTimeout</code> to create some sort of asynchronous behavior? </p>
						<p>Yes! However, within the Event Loop, there are actually two types of queues: the <strong>(macro)task queue</strong> (or just called the <strong>task queue</strong>), and the <strong>microtask queue</strong>. The (macro)task queue is for <strong>(macro)tasks</strong> and the microtask queue is for <strong>microtasks</strong>.</p>
						<p>So what's a <em>(macro)task</em> and what's a <em>microtask</em>? Although there are a few more than I'll cover here, the most common are shown in the table below!</p>
						<p>
							<table>
								<tbody>
									<tr>
										<td> (Macro)task </td>
										<td>
											<code>setTimeout</code> | <code>setInterval</code> | <code>setImmediate</code>
										</td>
									</tr>
									<tr>
										<td> Microtask </td>
										<td>
											<code>process.nextTick</code> | <code>Promise callback</code> | <code>queueMicrotask</code>
										</td>
									</tr>
								</tbody>
							</table>
						</p>
						<p>Ahh, we see <code>Promise</code> in the microtask list! 😃 When a <code>Promise</code> resolves and calls its <code>then()</code>, <code>catch()</code> or <code>finally()</code>, method, the callback within the method gets added to the <strong>microtask queue</strong>! This means that the callback within the <code>then()</code>, <code>catch()</code> or <code>finally()</code> method isn't executed immediately, essentially adding some async behavior to our JavaScript code! </p>
						<p>So when <em>is</em> a <code>then()</code>, <code>catch()</code> or <code>finally()</code> callback executed? The event loop gives a different priority to the tasks:</p>
						<ol>
							<li>All functions in that are currently in the <strong>call stack</strong> get executed. When they returned a value, they get popped off the stack.</li>
							<li>When the call stack is empty, <em>all</em> queued up <strong>microtasks</strong> are popped onto the callstack one by one, and get executed! (Microtasks themselves can also return new microtasks, effectively creating an infinite microtask loop 😬)</li>
							<li>If both the call stack and microtask queue are empty, the event loop checks if there are tasks left on the (macro)task queue. The tasks get popped onto the callstack, executed, and popped off! </li>
						</ol>
						<h3>Example</h3>
						<h5>Let's take a look at a quick example, simply using:</h5>
						<ul>
							<li>
								<code>Task1</code>: a function that's added to the call stack immediately, for example by invoking it instantly in our code. </li>
							<li>
								<code>Task2</code>, <code>Task3</code>, <code>Task4</code>: microtasks, for example a promise <code>then</code> callback, or a task added with <code>queueMicrotask</code>. </li>
							<li>
								<code>Task5</code>, <code>Task6</code>: a (macro)task, for example a <code>setTimeout</code> or <code>setImmediate</code> callback </li>
						</ul>
						<img src="./img/roadmap/js/promises/7.gif" />
						<p>First, <code>Task1</code> returned a value and got popped off the call stack. Then, the engine checked for tasks queued in the microtask queue. Once all the tasks were put on the call stack and eventually popped off, the engine checked for tasks on the (macro)task queue, which got popped onto the call stack, and popped off when they returned a value.</p>
						<h5>Let's use it with some real code!</h5>
						<img src="./img/roadmap/js/promises/7.png" />
						<p>In this code, we have the macro task <code>setTimeout</code>, and the microtask promise <code>then()</code> callback. Once the engine reaches the line of the <code>setTimeout</code> function. Let's run this code step-by-step, and see what gets logged!</p>
						<p>On the first line, the engine encounters the <code>console.log()</code> method. It gets added to the call stack, after which it logs the value <code>Start!</code> to the console. The method gets popped off the call stack, and the engine continues.</p>
						<img src="./img/roadmap/js/promises/8.gif" />
						<p>The engine encounters the <code>setTimeout</code> method, which gets popped on to the call stack. The <code>setTimeout</code> method is native to the browser: its callback function (<code>() =&gt; console.log('In timeout')</code>) will get added to the Web API, until the timer is done. Although we provided the value <code>0</code> for the timer, the call back still gets pushed to the Web API first, after which it gets added to the <strong>(macro)task queue</strong>: <code>setTimeout</code> is a macro task!</p>
						<img src="./img/roadmap/js/promises/9.gif" />
						<p>The engine encounters the <code>Promise.resolve()</code> method. The <code>Promise.resolve()</code> method gets added to the call stack, after which is resolves with the value <code>Promise!</code>. Its callback function, the <code>then()</code> method in this case, gets added to the <strong>microtask queue</strong>.</p>
						<img src="./img/roadmap/js/promises/10.gif" />
						<p>The engine encounters the <code>console.log()</code> method. It gets added to the call stack immediately, after which it logs the value <code>End!</code> to the console, gets popped off the call stack, and the engine continues.</p>
						<img src="./img/roadmap/js/promises/11.gif" />
						<p>The engine sees the callstack is empty now. Since the call stack is empty, it's going to check whether there are queued tasks in the <strong>microtask queue</strong>! And yes there are, the promise <code>then</code> callback is waiting for its turn! It gets popped onto the call stack, after which it logs the resolved value of the promise: the string <code>Promise!</code>in this case.</p>
						<img src="./img/roadmap/js/promises/12.gif" />
						<p>The engine sees the call stack is empty, so it's going to check the microtask queue once again to see if tasks are queued. Nope, the microqueue is all empty.</p>
						<p>It's time to check the <strong>(macro)task queue</strong>: the <code>setTimeout</code> callback is still waiting there! The <code>setTimeout</code> callback gets popped on to the callstack. The callback function returns the <code>console.log</code> method, which logs the string <code>"In timeout!"</code>. The <code>setTimeout</code> callback get popped off the callstack.</p>
						<img src="./img/roadmap/js/promises/13.gif" />
						<p>Finally, all done! 🥳 It seems like the output we saw earlier wasn't so unexpected after all.</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsAsync">
					<div class="roadmap__content-item-title">Async/Await</div>
					<div class="roadmap__content-text">
						<img src="./img/roadmap/js/async/head.webp" alt="" class="head" />
						<p>ES7 introduced a new way to add async behavior in JavaScript and make working with promises easier! With the introduction of the <code>async</code> and <code>await</code> keywords, we can create <strong>async</strong> functions which implicitly return a promise. But.. how can we do that? 😮</p>
						<p>Previously, we saw that we can explicitly create promises using the <code>Promise</code> object, whether it was by typing <code>new Promise(() =&gt; {})</code>, <code>Promise.resolve</code>, or <code>Promise.reject</code>. </p>
						<p>Instead of explicitly using the <code>Promise</code> object, we can now create asynchronous functions that <em>implicitly</em> return an object! This means that we no longer have to write any <code>Promise</code> object ourselves.</p>
						<img src="./img/roadmap/js/async/1.png" />
						<p>Although the fact that <strong>async</strong> functions implicitly return promises is pretty great, the real power of <code>async</code> functions can be seen when using the <code>await</code> keyword! With the <code>await</code> keyword, we can <em>suspend</em> the asynchronous function while we wait for the <code>await</code>ed value return a resolved promise. If we want to get the value of this resolved promise, like we previously did with the <code>then()</code> callback, we can assign variables to the <code>await</code>ed promise value!</p>
						<p>So, we can <em>suspend</em> an async function? Okay great but.. what does that even mean? </p>
						<p>Let's see what happens when we run the following block of code:</p>
						<img src="./img/roadmap/js/async/1.gif" />
						<p>Hmm.. What's happening here?</p>
						<img src="./img/roadmap/js/async/2.gif" />
						<p>First, the engine encounters a <code>console.log</code>. It gets popped onto the call stack, after which <code>Before function!</code> gets logged.</p>
						<img src="./img/roadmap/js/async/3.gif" />
						<p>Then, we invoke the async function <code>myFunc()</code>, after which the function body of <code>myFunc</code> runs. On the very first line within the function body, we call another <code>console.log</code>, this time with the string <code>In function!</code>. The <code>console.log</code> gets added to the call stack, logs the value, and gets popped off.</p>
						<img src="./img/roadmap/js/async/4.gif" />
						<p>The function body keeps on being executed, which gets us to the second line. Finally, we see an <code>await</code> keyword! 🎉 </p>
						<p>The first thing that happens is that the value that gets awaited gets executed: the function <code>one</code> in this case. It gets popped onto the call stack, and eventually returns a resolved promise. Once the promise has resolved and <code>one</code> returned a value, the engine encounters the <code>await</code> keyword. </p>
						<p>When encountering an <code>await</code> keyword, the <code>async</code> function gets <em>suspended</em>. ✋🏼 The execution of the function body <strong>gets paused</strong>, and the rest of the async function gets run in a <em>microtask</em> instead of a regular task! </p>
						<img src="./img/roadmap/js/async/5.gif" />
						<p>Now that the async function <code>myFunc</code> is suspended as it encountered the <code>await</code> keyword, the engine jumps out of the async function and continues executing the code in the execution context in which the async function got called: the <strong>global execution context</strong> in this case! 🏃🏽‍♀️</p>
						<img src="./img/roadmap/js/async/6.gif" />
						<p>Finally, there are no more tasks to run in the global execution context! The event loop checks to see if there are any microtasks queued up: and there are! The async <code>myFunc</code> function is queued up after resolving the valued of <code>one</code>. <code>myFunc</code> gets popped back onto the call stack, and continues running where it previously left off.</p>
						<p>The variable <code>res</code> finally gets its value, namely the value of the resolved promise that <code>one</code> returned! We invoke <code>console.log</code> with the value of <code>res</code>: the string <code>One!</code> in this case. <code>One!</code> gets logged to the console and gets popped off the call stack! 😊</p>
						<p>Finally, all done! Did you notice how <code>async</code> functions are different compared to a promise <code>then</code>? The <code>await</code> keyword <em>suspends</em> the <code>async</code> function, whereas the Promise body would've kept on being executed if we would've used <code>then</code>!</p>
						<a href="https://github.com/domenic/promises-unwrapping" target="_blank">Promises better understanding</a>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsFetch">
					<div class="roadmap__content-item-title">Fetch</div>
					<div class="roadmap__content-text">
						<p>Fetch is a new-ish, promise-based API that lets us do Ajax requests without all the fuss associated with <strong>XMLHttpRequest</strong>. As you’ll see in this post, Fetch is very easy to use and work with and greatly simplifies fetching resources from an API. Plus, it’s now supported in all modern browsers, so using Fetch is really a no-brainer.</p>
						<h5>Get Requests</h5>
						<p>Let’s demonstrate a simple GET request by going and <em>GET</em> ourselves some dummy data from the <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> API:</p>
						<pre>
	<code class="language-javascript line-numbers">
		fetch('https://jsonplaceholder.typicode.com/users')
		  .then(res => res.json())
		  .then(res => res.map(user => user.username))
		  .then(userNames => console.log(userNames));
	</code>
</pre>
						<p>And the output will be an array of user names like this:</p>
						<pre>
	<code class="language-javascript line-numbers">
		["Bret", "Antonette", "Samantha", "Karianne", "Kamren", "Leopoldo_Corkery", "Elwyn.Skiles", "Maxime_Nienow", "Delphine", "Moriah.Stanton"]
	</code>
</pre>
						<p>Given that we expect a JSON response, we first need to call the <code>json()</code> method to transform the <code>Response</code> object into an object that we can interact with. The <code class="highlighter-rouge">text()</code> could be used if we expected an XML response instead.</p>
						<h5>Post, Put and Delete Requests</h5>
						<p>To make requests other than <strong>GET</strong>, pass-in an object as a second argument to a fetch call with the method to use as well as any needed headers and the body of the request:</p>
						<pre>
	<code class="language-javascript line-numbers">
		const myPost = {
		  title: 'A post about true facts',
		  body: '42',
		  userId: 2
		}

		const options = {
		  method: 'POST',
		  body: JSON.stringify(myPost),
		  headers: {
		    'Content-Type': 'application/json'
		  }
		};

		fetch('https://jsonplaceholder.typicode.com/posts', options)
		  .then(res => res.json())
		  .then(res => console.log(res));
	</code>
</pre>
						<p><strong>JSONPlaceholder</strong> sends us the POSTed data back with an ID attached:</p>
						<pre>
	<code class="language-javascript line-numbers">
		Object {
		  body: 42,
		  id: 101,
		  title: "A post about true facts",
		  userId: 2
		}
	</code>
</pre>
						<p><b>You'll note that the request body needs to be stringified. Other methods that you can use for fetch calls are DELETE, PUT, HEAD and OPTIONS</b></p>
						<h5>Error Handling</h5>
						<p>There’s a catch (pun intended 😉) when it comes to error handling with the Fetch API: if the request properly hits the endpoint and comes back, no error will be thrown. This means that error handling is not as simple as chaining a <code>catch</code> call at then end of your fetch promise chain.</p>
						<p>Luckily though, the response object from a fetch call has an <code>ok</code> property that will be either true of false depending on the success of the request. You can then use <code>Promise.reject()</code> if <code>ok</code> is false:</p>
						<pre>
	<code class="language-javascript line-numbers">
		fetch('https://jsonplaceholder.typicode.com/postsZZZ', options)
		  .then(res => {
		    if (res.ok) {
		      return res.json();
		    } else {
		      return Promise.reject({ status: res.status, statusText: res.statusText });
		    }
		  })
		  .then(res => console.log(res))
		  .catch(err => console.log('Error, with message:', err.statusText));
	</code>
</pre>
						<p>With the above example our promise will reject because we’re calling an endpoint that doesn’t exist. The chained catch call will be hit and the following will be outputted:</p>
						<pre>
	<code class="language-javascript line-numbers">
		"Error, with message: Not Found"
	</code>
</pre>
						<h4>Fetch + Async/Await</h4>
						<p>Since Fetch is a promise-based API, using <code>async</code> functions is a great option to make your code even easier to reason about and synchronous-looking. Here for example is an <strong>async/await</strong> function that performs a simple <strong>GET</strong> request and extracts the usernames from the returned JSON response to then log the result at the console:</p>
						<pre>
	<code class="language-javascript line-numbers">
		async function fetchUsers(endpoint) {
		  const res = await fetch(endpoint);
		  let data = await res.json();

		  data = data.map(user => user.username);

		  console.log(data);
		}

		fetchUsers('https://jsonplaceholder.typicode.com/users');
	</code>
</pre>
						<p>Or, you could just return a promise from your async/await function and then you’d have the ability to keep-on chaining <code>then</code> calls after calling the function:</p>
						<pre>
	<code class="language-javascript line-numbers">
		async function fetchUsers(endpoint) {
		  const res = await fetch(endpoint);
		  const data = await res.json();

		  return data;
		}

		fetchUsers('https://jsonplaceholder.typicode.com/users')
		  .then(data => {
		    console.log(data.map(user => user.username));
		  });
	</code>
</pre>
						<p class="info-box"> Calling <em>json()</em> returns a promise so in the above example, when we <code class="h">return data</code> in the async function, we're returning a promise.</p>
						<p>And then again you could also throw an error if the response’s <em>ok</em> is false and catch the error as usual in your promise chain:</p>
						<pre>
	<code class="language-javascript line-numbers">
		async function fetchUsers(endpoint) {
		  const res = await fetch(endpoint);

		  if (!res.ok) {
		    throw new Error(res.status); // 404
		  }

		  const data = await res.json();
		  return data;
		}

		fetchUsers('https://jsonplaceholder.typicode.com/usersZZZ')
		  .then(data => {
		    console.log(data.map(user => user.website));
		  })
		  .catch(err => console.log('Ooops, error', err.message));
	</code>
</pre>
						<pre>
	<code class="language-javascript line-numbers">
		Ooops, error 404
	</code>
</pre>
						<h3>Polyfills</h3>
						<ul>
							<li>If you need to support older browsers, like Internet Explorer 11, you’ll need to use a Fetch polyfill <a href="https://github.com/github/fetch">like this one from Github</a>.</li>
							<li>If you need to use Fetch in Node.js, two of the most popular options are <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> and <a href="https://github.com/bitinn/node-fetch">node-fetch</a>.</li>
						</ul>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsAxios">
					<div class="roadmap__content-item-title">Axios</div>
					<div class="roadmap__content-text">
						<iframe title="Axios" src="https://alligator.io/js/axios-vanilla-js/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsArrayReduce">
					<div class="roadmap__content-item-title">Array Reduce</div>
					<div class="roadmap__content-text">
						<iframe title="jsArrayReduce" src="https://alligator.io/js/finally-understand-reduce/">
						</iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsES6">
					<div class="roadmap__content-item-title">ES6</div>
					<div class="roadmap__content-text">
						<h3>Basic Vocabulary</h3>
						<pre class="language-javascript">
	<code>
		var a = 7 + "2";
	</code>
</pre>
						<p> "var a = 7 + "2";": Statement - A group of words, numbers and operators that do a task is a statement. </p>
						<p> "var": Keyword / <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" title='break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield'>reserved word</a> - Any word that is part of the vocabulary of the programming language is called a keyword. </p>
						<p> "a": Variable - A named reference to a value is a variable. </p>
						<p> "=, +": Operator - Operators are reserved-words that perform action on values and variables </p>
						<p> "7 + "2"": Expression - A reference, value or a group of reference(s) and value(s) combined with operator(s), <strong>which result in a single value</strong>. </p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsModules">
					<div class="roadmap__content-item-title">ES6 Modules</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/modules-es6/" /></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsNumbers">
					<div class="roadmap__content-item-title">Numbers</div>
					<div class="roadmap__content-text">
						<h3>Basic Vocabulary</h3>
						<pre class="language-javascript">
	<code>
		var a = 7 + "2";
	</code>
</pre>
						<p> "var a = 7 + "2";": Statement - A group of words, numbers and operators that do a task is a statement. </p>
						<p> "var": Keyword / <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" title='break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield'>reserved word</a> - Any word that is part of the vocabulary of the programming language is called a keyword. </p>
						<p> "a": Variable - A named reference to a value is a variable. </p>
						<p> "=, +": Operator - Operators are reserved-words that perform action on values and variables </p>
						<p> "7 + "2"": Expression - A reference, value or a group of reference(s) and value(s) combined with operator(s), <strong>which result in a single value</strong>. </p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="jsDOM">
					<div class="roadmap__content-item-title">DOM</div>
					<div class="roadmap__content-text">
						<iframe title="dealing-with-objects" src="https://alligator.io/js/getting-elements/" /></iframe>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="js">
					<div class="roadmap__content-item-title">Fetch API / Ajax</div>
					<div class="roadmap__content-text">
						<h4>Data Types</h4>
						<pre class="language-javascript">
	<code>
		"Any text" // 1. String
		123.45 // 2. Number
		true or false // 3. Boolean
		null // 4. Null
		undefined // 5. Undefined
		Symbol('something') // 6. Symbol
		{ key: 'value'} // 7. Object
		[1, "text", false] // - Array
		function name() { } // - Function
	</code>
</pre>
						<h4>Object</h4>
						<p>An object is a data type in JavaScript that is used to store a combination of data in a simple key-value pair.</p>
						<pre class="language-javascript">
	<code>
		var hero = {
		name: "Thor",
		yearOfBirth: '-15621651',
		calculateAge: function(){
		// some code to calculate age
	}
}

</code>
</pre>
						<h4>Function</h4>
						<p>Функция — это мини-программа, которая получает на вход какие-то данные, что-то делает внутри себя и может отдавать какие-то данные в результате вычислений.</p>
						<h3>OOP</h3>
						<h4>Объект</h4>
						<p>Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм</p>
						<ul>
							<li>
								<p><span>инкапсуляция</span> — объект независим</p>
								<p>Нужные для объекта данные живут внутри этого объекта, а не где-то снаружи в программе (например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку»). Также означает скрытие внутренней реализации от других компонентов. Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения (<a target="blank" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title='Метод чтения, геттер (getter — получатель) — специальный метод, позволяющий получить данные, доступ к которым напрямую ограничен.'>геттер</a>) и изменения (<a target="blank" href="" title='Устанавливающий метод, сеттер (англ. setter) или модифицирующий метод, мутатор (англ. mutator) — метод, используемый в объектно-ориентированном программировании для того, чтобы присвоить какое-либо значение инкапсулированному полю, например, обработав при этом недопустимые присваивания.'>сеттер</a>) её значения.</p>
							</li>
							<li>
								<p><span>абстракция</span> — у объекта есть «<a target="blank" href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)' title="Интерфе́йс (англ. interface) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).">интерфейс</a>»</p>
								<p>Aбстракция нужна что бы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи</p>
								<p>у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс. В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения. Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/7-1.jpg" alt="" />
							</li>
							<li>
								<p><span>наследование</span> — единый язык общения</p>
								<p>ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать. Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить». На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у идеального покупателя, плюс могут быть какие-то свои, если захотите. Идеальные объекты программисты называют классами.</p>
							</li>
							<li>
								<p><span>полиморфизм</span> — способность к копированию</p>
								<p>В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть». При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/8-1.jpg" alt="" />
								<p>Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если правила работы с ним остались прежними.</p>
							</li>
						</ul>
						<p>Плюсы и минусы ООП У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов. Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объект и из чего он состоит. Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием. Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок. Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип. А теперь про минусы: Сложно понять и начать работать. Подход ООП намного сложнее обычного процедурного программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода. Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная. Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем процедурная (хотя с современными мощностями процессоров это мало кого волнует).</p>
						<p>Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании</p>
						<p>данные внутри объекта называются свойствами, а функции — методами</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="js">
					<div class="roadmap__content-item-title">ES6+ and modules</div>
					<div class="roadmap__content-text">
						<h4>Data Types</h4>
						<pre class="language-javascript">
	<code>
		"Any text" // 1. String
		123.45 // 2. Number
		true or false // 3. Boolean
		null // 4. Null
		undefined // 5. Undefined
		Symbol('something') // 6. Symbol
		{ key: 'value'} // 7. Object
		[1, "text", false] // - Array
		function name() { } // - Function
	</code>
</pre>
						<h4>Object</h4>
						<p>An object is a data type in JavaScript that is used to store a combination of data in a simple key-value pair.</p>
						<pre class="language-javascript">
	<code>
		var hero = {
		name: "Thor",
		yearOfBirth: '-15621651',
		calculateAge: function(){
		// some code to calculate age
	}
}

</code>
</pre>
						<h4>Function</h4>
						<p>Функция — это мини-программа, которая получает на вход какие-то данные, что-то делает внутри себя и может отдавать какие-то данные в результате вычислений.</p>
						<h3>OOP</h3>
						<h4>Объект</h4>
						<p>Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм</p>
						<ul>
							<li>
								<p><span>инкапсуляция</span> — объект независим</p>
								<p>Нужные для объекта данные живут внутри этого объекта, а не где-то снаружи в программе (например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку»). Также означает скрытие внутренней реализации от других компонентов. Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения (<a target="blank" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title='Метод чтения, геттер (getter — получатель) — специальный метод, позволяющий получить данные, доступ к которым напрямую ограничен.'>геттер</a>) и изменения (<a target="blank" href="" title='Устанавливающий метод, сеттер (англ. setter) или модифицирующий метод, мутатор (англ. mutator) — метод, используемый в объектно-ориентированном программировании для того, чтобы присвоить какое-либо значение инкапсулированному полю, например, обработав при этом недопустимые присваивания.'>сеттер</a>) её значения.</p>
							</li>
							<li>
								<p><span>абстракция</span> — у объекта есть «<a target="blank" href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)' title="Интерфе́йс (англ. interface) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).">интерфейс</a>»</p>
								<p>Aбстракция нужна что бы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи</p>
								<p>у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс. В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения. Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/7-1.jpg" alt="" />
							</li>
							<li>
								<p><span>наследование</span> — единый язык общения</p>
								<p>ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать. Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить». На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у идеального покупателя, плюс могут быть какие-то свои, если захотите. Идеальные объекты программисты называют классами.</p>
							</li>
							<li>
								<p><span>полиморфизм</span> — способность к копированию</p>
								<p>В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть». При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/8-1.jpg" alt="" />
								<p>Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если правила работы с ним остались прежними.</p>
							</li>
						</ul>
						<p>Плюсы и минусы ООП У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов. Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объект и из чего он состоит. Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием. Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок. Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип. А теперь про минусы: Сложно понять и начать работать. Подход ООП намного сложнее обычного процедурного программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода. Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная. Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем процедурная (хотя с современными мощностями процессоров это мало кого волнует).</p>
						<p>Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании</p>
						<p>данные внутри объекта называются свойствами, а функции — методами</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="js">
					<div class="roadmap__content-item-title">Language concepts</div>
					<div class="roadmap__content-text">
						<h4>Data Types</h4>
						<pre class="language-javascript">
	<code>
		"Any text" // 1. String
		123.45 // 2. Number
		true or false // 3. Boolean
		null // 4. Null
		undefined // 5. Undefined
		Symbol('something') // 6. Symbol
		{ key: 'value'} // 7. Object
		[1, "text", false] // - Array
		function name() { } // - Function
	</code>
</pre>
						<h4>Object</h4>
						<p>An object is a data type in JavaScript that is used to store a combination of data in a simple key-value pair.</p>
						<pre class="language-javascript">
	<code>
		var hero = {
		name: "Thor",
		yearOfBirth: '-15621651',
		calculateAge: function(){
		// some code to calculate age
	}
}

</code>
</pre>
						<h4>Function</h4>
						<p>Функция — это мини-программа, которая получает на вход какие-то данные, что-то делает внутри себя и может отдавать какие-то данные в результате вычислений.</p>
						<h3>OOP</h3>
						<h4>Объект</h4>
						<p>Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм</p>
						<ul>
							<li>
								<p><span>инкапсуляция</span> — объект независим</p>
								<p>Нужные для объекта данные живут внутри этого объекта, а не где-то снаружи в программе (например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку»). Также означает скрытие внутренней реализации от других компонентов. Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения (<a target="blank" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title='Метод чтения, геттер (getter — получатель) — специальный метод, позволяющий получить данные, доступ к которым напрямую ограничен.'>геттер</a>) и изменения (<a target="blank" href="" title='Устанавливающий метод, сеттер (англ. setter) или модифицирующий метод, мутатор (англ. mutator) — метод, используемый в объектно-ориентированном программировании для того, чтобы присвоить какое-либо значение инкапсулированному полю, например, обработав при этом недопустимые присваивания.'>сеттер</a>) её значения.</p>
							</li>
							<li>
								<p><span>абстракция</span> — у объекта есть «<a target="blank" href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)' title="Интерфе́йс (англ. interface) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).">интерфейс</a>»</p>
								<p>Aбстракция нужна что бы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи</p>
								<p>у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс. В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения. Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/7-1.jpg" alt="" />
							</li>
							<li>
								<p><span>наследование</span> — единый язык общения</p>
								<p>ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать. Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить». На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у идеального покупателя, плюс могут быть какие-то свои, если захотите. Идеальные объекты программисты называют классами.</p>
							</li>
							<li>
								<p><span>полиморфизм</span> — способность к копированию</p>
								<p>В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть». При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.</p>
								<img src="https://thecode.media/wp-content/uploads/2019/09/8-1.jpg" alt="" />
								<p>Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если правила работы с ним остались прежними.</p>
							</li>
						</ul>
						<p>Плюсы и минусы ООП У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов. Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объект и из чего он состоит. Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием. Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок. Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип. А теперь про минусы: Сложно понять и начать работать. Подход ООП намного сложнее обычного процедурного программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода. Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная. Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем процедурная (хотя с современными мощностями процессоров это мало кого волнует).</p>
						<p>Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании</p>
						<p>данные внутри объекта называются свойствами, а функции — методами</p>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="html">
					<div class="roadmap__content-item-title">HTML</div>
					<div class="roadmap__content-text">
						<p> HTML (от англ. HyperText Markup Language — «язык гипертекстовой разметки») — язык разметки, определяющий структуру веб-страниц. </p>
						<img src="https://mdn.mozillademos.org/files/7659/anatomy-of-an-html-element.png" alt="" />
						<p> HTML принято сохранять с расширением .htm или .html, которые обслуживаются сервером, и могут воспроизводиться любым <a href="#" title='это программа которая извлекает и показывает страницы из Web, и даёт пользователям доступ к веб-страницам через гиперссылки.'>браузером</a>. </p>
						<p> HTML (HyperText Markup Language - язык гипертекстовой разметки) не является языком программирования; это язык разметки, используемый для определения структуры веб-страниц. HTML состоит из ряда элементов, которые вы используете для того, чтобы охватить, обернуть или разметить различные части содержимого, чтобы оно имело определенный вид или срабатывало определенным способом. Встроенные тэги могут преобразовать часть содержимого в гиперссылку, по которой можно перейти на другую веб-страницу, выделить курсивом слова и так далее. </p>
						<p> Основными частями элемента являются: Открывающий тег: Он состоит из названия (обозначения) элемента (в нашем случае, p), помещённого внутри угловых скобок. Данный тег служит признаком начала элемента, с этого момента тег начинает влиять на следующее после него содержимое. Закрывающий тег: выглядит как и открывающий, но содержит слэш перед названием тега. Он служит признаком конца элемента. Пропуски закрывающих тегов — типичная ошибка новичков, которая может приводить к неопределённым результатам — в лучшем случае всё сработает правильно, в других страница может вовсе не прорисоваться или прорисоваться не как ожидалось. Содержимое: Как видно, в нашем случае содержимым является простой текст. Элемент: открывающий тег + закрывающий тег + содержимое = элемент. </p>
						<!-- <p>
	Существует две важных категории элементов в HTML, которые вам стоит знать — элементы блочного уровня и строчные элементы.

	Элементы блочного уровня формируют видимый блок на странице — они окажутся на новой строке после любого контента, который шёл до них, и любой контент после них также окажется на новой строке. Чаще всего элементами блочного уровня бывают структурные элементы страницы, представляющие собой, например, параграфы (абзацы), списки, меню навигации, футеры, или подвалы, и т. п. Элементы блочного уровня не вкладываются в строчные элементы, но иногда могут вкладываться в другие элементы блочного уровня.
	Строчные элементы — это те, которые содержатся в элементах блочного уровня и окружают только малые части содержимого документа, не целые абзацы и группировки контента. Строчные элементы не приводят к появлению новой строки в документе: они обычно встречаются внутри абзаца текста, например, элемент <a> (ссылка) или акцентирующие элементы вроде <em> или <strong>.
	</p> -->
						<a href="https://html.spec.whatwg.org/multipage/indices.html#element-content-categories">Element content categories</a>
						<pre class="language-javascript">
		<code>
			alert('it works!');
		</code>
	</pre>
						<pre class="language-sass line-numbers">
		<code>
			.roadmap
				width: 100%
				min-height: 100vh
				display: flex

				&__left
					position: fixed
					left: 0
					top: 0
					height: 100%
					width: 100%
					max-width: 260px
					display: flex
					flex-direction: column
		</code>
	</pre>
						<pre class="language-javascript line-numbers">
		<code>
			const things = [
			'Playground',
			'Strategy',
			'Galley',
			'Mailman',
			'Reference',
			'Suit',
			];
		</code>
	</pre>
					</div>
				</div>
				<div class="roadmap__content-item js-content" data-content="htmlBasics">
					<div class="roadmap__content-item-title">Basics</div>
					<div class="roadmap__content-text"> htmlBasics </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="htmlBasics">
					<div class="roadmap__content-item-title">Semantic HTML</div>
					<div class="roadmap__content-text"> htmlBasics </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="htmlBasics">
					<div class="roadmap__content-item-title">Basic SEO</div>
					<div class="roadmap__content-text"> htmlBasics </div>
				</div>
				<div class="roadmap__content-item js-content" data-content="htmlBasics">
					<div class="roadmap__content-item-title">Accessibility</div>
					<div class="roadmap__content-text"> htmlBasics </div>
				</div>
			</div>
		</div>
		<!-- END content -->
		<!-- BEGIN scripts -->
		<script type="text/javascript" src="js/app.js"></script>
		<!-- END scripts -->
	</body>
</html>
